Token.__init__	Construct a Token object.	<p>Construct a <code>Token</code> object.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">doc = nlp(u'Give it back! He pleaded.')<br/>token = doc[0]<br/>assert token.text == u'Give'<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>vocab</code></td><td class="c-table__cell u-text"><code>Vocab</code></td><td class="c-table__cell u-text">A storage container for lexical types.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>doc</code></td><td class="c-table__cell u-text"><code>Doc</code></td><td class="c-table__cell u-text">The parent document.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>offset</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">The index of the token within the document.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code>Token</code></td><td class="c-table__cell u-text">The newly constructed object.</td></tr></table>
Token.__len__	The number of unicode characters in the token, i.e. token.text.	<p>The number of unicode characters in the token, i.e. <code>token.text</code>.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">doc = nlp(u'Give it back! He pleaded.')<br/>token = doc[0]<br/>assert len(token) == 4<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">The number of unicode characters in the token.</td></tr></table>
Token.set_extension	 Define a custom attribute on the Token which becomes available via Token._. For details, see the documentation on custom attributes.	<p> Define a custom attribute on the <code>Token</code> which becomes available via <code>Token._</code>. For details, see the documentation on <a href="../usage/processing-pipelines#custom-components-attributes">custom attributes</a>.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">from spacy.tokens import Token<br/>fruit_getter = lambda token: token.text in ('apple', 'pear', 'banana')<br/>Token.set_extension('is_fruit', getter=fruit_getter)<br/>doc = nlp(u'I have an apple')<br/>assert doc[3]._.is_fruit<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>name</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text"> Name of the attribute to set by the extension. For example, <code>'my_attr'</code> will be available as <code>token._.my_attr</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>default</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text"> Optional default value of the attribute if no getter or methodis defined.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>method</code></td><td class="c-table__cell u-text">callable</td><td class="c-table__cell u-text"> Set a custom method on the object, for example <code>token._.compare(other_token)</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>getter</code></td><td class="c-table__cell u-text">callable</td><td class="c-table__cell u-text"> Getter function that takes the object and returns an attribute value. Is called when the user accesses the <code>._</code> attribute.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>setter</code></td><td class="c-table__cell u-text">callable</td><td class="c-table__cell u-text"> Setter function that takes the <code>Token</code> and a value, and modifies the object. Is called when the user writes to the <code>Token._</code> attribute.</td></tr></table>
Token.get_extension	 Look up a previously registered extension by name. Returns a 4-tuple (default, method, getter, setter) if the extension is registered. Raises a KeyError otherwise.	<p> Look up a previously registered extension by name. Returns a 4-tuple <code class="u-break">(default, method, getter, setter)</code> if the extension is registered. Raises a <code>KeyError</code> otherwise.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">from spacy.tokens import Token<br/>Token.set_extension('is_fruit', default=False)<br/>extension = Token.get_extension('is_fruit')<br/>assert extension == (False, None, None, None)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>name</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">Name of the extension.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">tuple</td><td class="c-table__cell u-text"> A <code class="u-break">(default, method, getter, setter)</code> tuple of the extension.</td></tr></table>
Token.has_extension	Check whether an extension has been registered on the Token class.	<p>Check whether an extension has been registered on the <code>Token</code> class.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">from spacy.tokens import Token<br/>Token.set_extension('is_fruit', default=False)<br/>assert Token.has_extension('is_fruit')<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>name</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">Name of the extension to check.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text">Whether the extension has been registered.</td></tr></table>
Token.check_flag	Check the value of a boolean flag.	<p>Check the value of a boolean flag.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">from spacy.attrs import IS_TITLE<br/>doc = nlp(u'Give it back! He pleaded.')<br/>token = doc[0]<br/>assert token.check_flag(IS_TITLE) == True<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>flag_id</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">The attribute ID of the flag to check.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text">Whether the flag is set.</td></tr></table>
Token.similarity	Compute a semantic similarity estimate. Defaults to cosine over vectors.	<p>Compute a semantic similarity estimate. Defaults to cosine over vectors.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">apples, _, oranges = nlp(u'apples and oranges')<br/>apples_oranges = apples.similarity(oranges)<br/>oranges_apples = oranges.similarity(apples)<br/>assert apples_oranges == oranges_apples<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text">other</td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text"> The object to compare with. By default, accepts <code>Doc</code>, <code>Span</code>, <code>Token</code> and <code>Lexeme</code> objects.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">float</td><td class="c-table__cell u-text">A scalar similarity score. Higher is more similar.</td></tr></table>
Token.nbor	Get a neighboring token.	<p>Get a neighboring token.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">doc = nlp(u'Give it back! He pleaded.')<br/>give_nbor = doc[0].nbor()<br/>assert give_nbor.text == u'it'<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>i</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">The relative position of the token to get. Defaults to <code>1</code>.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code>Token</code></td><td class="c-table__cell u-text">The token at position <code>self.doc[self.i+i]</code>.</td></tr></table>
Token.is_ancestor	 Check whether this token is a parent, grandparent, etc. of another
in the dependency tree.	<p> Check whether this token is a parent, grandparent, etc. of anotherin the dependency tree.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">doc = nlp(u'Give it back! He pleaded.')<br/>give = doc[0]<br/>it = doc[1]<br/>assert give.is_ancestor(it)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text">descendant</td><td class="c-table__cell u-text"><code>Token</code></td><td class="c-table__cell u-text">Another token.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text">Whether this token is the ancestor of the descendant.</td></tr></table>
Token.ancestors	The rightmost token of this token's syntactic descendants.	<p>The rightmost token of this token's syntactic descendants.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">doc = nlp(u'Give it back! He pleaded.')<br/>it_ancestors = doc[1].ancestors<br/>assert [t.text for t in it_ancestors] == [u'Give']<br/>he_ancestors = doc[4].ancestors<br/>assert [t.text for t in he_ancestors] == [u'pleaded']<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">yields</td><td class="c-table__cell u-text"><code>Token</code></td><td class="c-table__cell u-text"> A sequence of ancestor tokens such that <code>ancestor.is_ancestor(self)</code>.</td></tr></table>
Token.conjuncts	A sequence of coordinated tokens, including the token itself.	<p>A sequence of coordinated tokens, including the token itself.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">doc = nlp(u'I like apples and oranges')<br/>apples_conjuncts = doc[2].conjuncts<br/>assert [t.text for t in apples_conjuncts] == [u'oranges']<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">yields</td><td class="c-table__cell u-text"><code>Token</code></td><td class="c-table__cell u-text">A coordinated token.</td></tr></table>
Token.children	A sequence of the token's immediate syntactic children.	<p>A sequence of the token's immediate syntactic children.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">doc = nlp(u'Give it back! He pleaded.')<br/>give_children = doc[0].children<br/>assert [t.text for t in give_children] == [u'it', u'back', u'!']<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">yields</td><td class="c-table__cell u-text"><code>Token</code></td><td class="c-table__cell u-text">A child token such that <code>child.head==self</code>.</td></tr></table>
Token.lefts	 The leftward immediate children of the word, in the syntactic dependency
parse.	<p> The leftward immediate children of the word, in the syntactic dependencyparse.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">doc = nlp(u'I like New York in Autumn.')<br/>lefts = [t.text for t in doc[3].lefts]<br/>assert lefts == [u'New']<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">yields</td><td class="c-table__cell u-text"><code>Token</code></td><td class="c-table__cell u-text">A left-child of the token.</td></tr></table>
Token.rights	 The rightward immediate children of the word, in the syntactic
dependency parse.	<p> The rightward immediate children of the word, in the syntacticdependency parse.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">doc = nlp(u'I like New York in Autumn.')<br/>rights = [t.text for t in doc[3].rights]<br/>assert rights == [u'in']<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">yields</td><td class="c-table__cell u-text"><code>Token</code></td><td class="c-table__cell u-text">A right-child of the token.</td></tr></table>
Token.n_lefts	 The number of leftward immediate children of the word, in the syntactic
dependency parse.	<p> The number of leftward immediate children of the word, in the syntacticdependency parse.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">doc = nlp(u'I like New York in Autumn.')<br/>assert doc[3].n_lefts == 1<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">The number of left-child tokens.</td></tr></table>
Token.n_rights	 The number of rightward immediate children of the word, in the syntactic
dependency parse.	<p> The number of rightward immediate children of the word, in the syntacticdependency parse.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">doc = nlp(u'I like New York in Autumn.')<br/>assert doc[3].n_rights == 1<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">The number of right-child tokens.</td></tr></table>
Token.subtree	A sequence of all the token's syntactic descendents.	<p>A sequence of all the token's syntactic descendents.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">doc = nlp(u'Give it back! He pleaded.')<br/>give_subtree = doc[0].subtree<br/>assert [t.text for t in give_subtree] == [u'Give', u'it', u'back', u'!']<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">yields</td><td class="c-table__cell u-text"><code>Token</code></td><td class="c-table__cell u-text">A descendant token such that <code>self.is_ancestor(descendant)</code>.</td></tr></table>
Token.is_sent_start	 A boolean value indicating whether the token starts a sentence. None if unknown.	<p> A boolean value indicating whether the token starts a sentence. <code>None</code> if unknown.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">doc = nlp(u'Give it back! He pleaded.')<br/>assert doc[4].is_sent_start<br/>assert not doc[5].is_sent_start<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text">Whether the token starts a sentence.</td></tr></table><aside class="o-box o-block u-text-small"><h3 class="u-heading u-text-label u-color-theme"><span class="o-emoji">⚠️</span> Changed in v2.0</h3> As of spaCy v2.0, the <code>Token.sent_start</code> property is deprecated and has been replaced with <code>Token.is_sent_start</code>, which returns a boolean value instead of a misleading <code>0</code> for <code>False</code> and <code>1</code> for <code>True</code>. It also now returns <code>None</code> if the answer is unknown, and fixes a quirk in the old logic that would always set the property to <code>0</code> for the first word of the document.<span class="u-inline-block u-padding-top u-width-full"><pre aria-label="correct" class="c-code-block o-block lang-python c-code-block--has-icon o-block-small" data-language="python"><div class="c-code-block__icon u-color-green c-code-block__icon--border"><svg aria-hidden="true" class="o-icon" height="18" style="min-width: 18px" viewbox="0 0 18 18" width="18"><use xlink:href="#svg_accept"></use></svg></div><code class="c-code-block__content">assert doc[4].is_sent_start == True</code></pre><pre aria-label="incorrect" class="c-code-block o-block lang-python c-code-block--has-icon o-block-small" data-language="python"><div class="c-code-block__icon u-color-red c-code-block__icon--border"><svg aria-hidden="true" class="o-icon" height="18" style="min-width: 18px" viewbox="0 0 18 18" width="18"><use xlink:href="#svg_reject"></use></svg></div><code class="c-code-block__content">assert doc[4].sent_start == 1</code></pre></span></aside>
Token.has_vector	 A boolean value indicating whether a word vector is associated with the
token.	<p> A boolean value indicating whether a word vector is associated with thetoken.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">doc = nlp(u'I like apples')<br/>apples = doc[2]<br/>assert apples.has_vector<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text">Whether the token has a vector data attached.</td></tr></table>
Token.vector	A real-valued meaning representation.	<p>A real-valued meaning representation.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">doc = nlp(u'I like apples')<br/>apples = doc[2]<br/>assert apples.vector.dtype == 'float32'<br/>assert apples.vector.shape == (300,)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code class="u-break">numpy.ndarray[ndim=1, dtype='float32']</code></td><td class="c-table__cell u-text">A 1D numpy array representing the token's semantics.</td></tr></table>
Token.vector_norm	The L2 norm of the token's vector representation.	<p>The L2 norm of the token's vector representation.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">doc = nlp(u'I like apples and pasta')<br/>apples = doc[2]<br/>pasta = doc[4]<br/>apples.vector_norm # 6.89589786529541<br/>pasta.vector_norm # 7.759851932525635<br/>assert apples.vector_norm != pasta.vector_norm<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">float</td><td class="c-table__cell u-text">The L2 norm of the vector representation.</td></tr></table>
Attributes		<table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>text</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">Verbatim text content.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>text_with_ws</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">Text content, with trailing space character if present.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>whitespace_</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">Trailing space character if present.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>orth</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">ID of the verbatim text content.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>orth_</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text"> Verbatim text content (identical to <code>Token.text</code>). Existst mostly for consistency with the other attributes.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>vocab</code></td><td class="c-table__cell u-text"><code>Vocab</code></td><td class="c-table__cell u-text">The vocab object of the parent <code>Doc</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>doc</code></td><td class="c-table__cell u-text"><code>Doc</code></td><td class="c-table__cell u-text">The parent document.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>head</code></td><td class="c-table__cell u-text"><code>Token</code></td><td class="c-table__cell u-text">The syntactic parent, or "governor", of this token.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>left_edge</code></td><td class="c-table__cell u-text"><code>Token</code></td><td class="c-table__cell u-text">The leftmost token of this token's syntactic descendants.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>right_edge</code></td><td class="c-table__cell u-text"><code>Token</code></td><td class="c-table__cell u-text">The rightmost token of this token's syntactic descendents.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>i</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">The index of the token within the parent document.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>ent_type</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">Named entity type.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>ent_type_</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">Named entity type.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>ent_iob</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text"> IOB code of named entity tag. <code>"B"</code> means the token begins an entity, <code>"I"</code> means it is inside an entity, <code>"O"</code> means it is outside an entity, and <code>""</code> means no entity tag is set.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>ent_iob_</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text"> IOB code of named entity tag. <code>"B"</code> means the token begins an entity, <code>"I"</code> means it is inside an entity, <code>"O"</code> means it is outside an entity, and <code>""</code> means no entity tag is set.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>ent_id</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text"> ID of the entity the token is an instance of, if any. Usuallyassigned by patterns in the Matcher.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>ent_id_</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text"> ID of the entity the token is an instance of, if any. Usuallyassigned by patterns in the Matcher.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>lemma</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text"> Base form of the token, with no inflectional suffixes.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>lemma_</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">Base form of the token, with no inflectional suffixes.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>norm</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text"> The token's norm, i.e. a normalised form of the token text.Usually set in the language's <a href="../usage/adding-languages#tokenizer-exceptions">tokenizer exceptions</a> or <a href="../usage/adding-languages#norm-exceptions">norm exceptions</a>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>norm_</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text"> The token's norm, i.e. a normalised form of the token text.Usually set in the language's <a href="../usage/adding-languages#tokenizer-exceptions">tokenizer exceptions</a> or <a href="../usage/adding-languages#norm-exceptions">norm exceptions</a>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>lower</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">Lowercase form of the token.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>lower_</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text"> Lowercase form of the token text. Equivalent to <code>Token.text.lower()</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>shape</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text"> Transform of the tokens's string, to show orthographic features.For example, "Xxxx" or "dd".</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>shape_</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text"> Transform of the tokens's string, to show orthographic features.For example, "Xxxx" or "dd".</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>prefix</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text"> Hash value of a length-N substring from the start of the token. Defaults to <code>N=1</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>prefix_</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text"> A length-N substring from the start of the token. Defaults to <code>N=1</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>suffix</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text"> Hash value of a length-N substring from the end of the token. Defaults to <code>N=3</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>suffix_</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text"> Length-N substring from the end of the token. Defaults to <code>N=3</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>is_alpha</code></td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text"> Does the token consist of alphabetic characters? Equivalent to <code>token.text.isalpha()</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>is_ascii</code></td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text"> Does the token consist of ASCII characters? Equivalent to <code>[any(ord(c) &gt;= 128 for c in token.text)]</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>is_digit</code></td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text"> Does the token consist of digits? Equivalent to <code>token.text.isdigit()</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>is_lower</code></td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text"> Is the token in lowercase? Equivalent to <code>token.text.islower()</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>is_upper</code></td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text"> Is the token in uppercase? Equivalent to <code>token.text.isupper()</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>is_title</code></td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text"> Is the token in titlecase? Equivalent to <code>token.text.istitle()</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>is_punct</code></td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text">Is the token punctuation?</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>is_left_punct</code></td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text">Is the token a left punctuation mark, e.g. <code>(</code>?</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>is_right_punct</code></td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text">Is the token a right punctuation mark, e.g. <code> </code>]?</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>is_space</code></td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text"> Does the token consist of whitespace characters? Equivalent to <code>token.text.isspace()</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>is_bracket</code></td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text">Is the token a bracket?</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>is_quote</code></td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text">Is the token a quotation mark?</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>is_currency</code><div class="u-text-tag u-text-tag--spaced" data-tooltip="This feature is new and was introduced in spaCy v2.0.8">v2.0.8 <span aria-role="tooltip" class="u-hidden">This feature is new and was introduced in spaCy v2.0.8</span></div></td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text">Is the token a currency symbol?</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>like_url</code></td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text">Does the token resemble a URL?</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>like_num</code></td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text">Does the token represent a number? e.g. "10.9", "10", "ten", etc.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>like_email</code></td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text">Does the token resemble an email address?</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>is_oov</code></td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text">Is the token out-of-vocabulary?</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>is_stop</code></td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text">Is the token part of a "stop list"?</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>pos</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">Coarse-grained part-of-speech.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>pos_</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">Coarse-grained part-of-speech.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>tag</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">Fine-grained part-of-speech.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>tag_</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">Fine-grained part-of-speech.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>dep</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">Syntactic dependency relation.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>dep_</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">Syntactic dependency relation.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>lang</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">Language of the parent document's vocabulary.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>lang_</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">Language of the parent document's vocabulary.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>prob</code></td><td class="c-table__cell u-text">float</td><td class="c-table__cell u-text">Smoothed log probability estimate of token's type.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>idx</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">The character offset of the token within the parent document.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>sentiment</code></td><td class="c-table__cell u-text">float</td><td class="c-table__cell u-text"> A scalar value indicating the positivity or negativity of thetoken.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>lex_id</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">Sequential ID of the token's lexical type.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>rank</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text"> Sequential ID of the token's lexical type, used to index intotables, e.g. for word vectors.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>cluster</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">Brown cluster ID.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>_</code></td><td class="c-table__cell u-text"><code>Underscore</code></td><td class="c-table__cell u-text"> User space for adding custom <a href="../usage/processing-pipelines#custom-components-attributes">attribute extensions</a>.</td></tr></table>
Lemmatizer.__init__	Create a Lemmatizer.	<p>Create a <code>Lemmatizer</code>.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">from spacy.lemmatizer import Lemmatizer<br/>lemmatizer = Lemmatizer()<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>index</code></td><td class="c-table__cell u-text">dict / <code>None</code></td><td class="c-table__cell u-text">Inventory of lemmas in the language.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>exceptions</code></td><td class="c-table__cell u-text">dict / <code>None</code></td><td class="c-table__cell u-text">Mapping of string forms to lemmas that bypass the <code>rules</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>rules</code></td><td class="c-table__cell u-text">dict / <code>None</code></td><td class="c-table__cell u-text">List of suffix rewrite rules.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>lookup</code></td><td class="c-table__cell u-text">dict / <code>None</code></td><td class="c-table__cell u-text">Lookup table mapping string to their lemmas.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code>Lemmatizer</code></td><td class="c-table__cell u-text">The newly created object.</td></tr></table>
Lemmatizer.__call__	Lemmatize a string.	<p>Lemmatize a string.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">from spacy.lemmatizer import Lemmatizer<br/>from spacy.lang.en import LEMMA_INDEX, LEMMA_EXC, LEMMA_RULES<br/>lemmatizer = Lemmatizer(LEMMA_INDEX, LEMMA_EXC, LEMMA_RULES)<br/>lemmas = lemmatizer(u'ducks', u'NOUN')<br/>assert lemmas == [u'duck']<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>string</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">The string to lemmatize, e.g. the token text.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>univ_pos</code></td><td class="c-table__cell u-text">unicode / int</td><td class="c-table__cell u-text">The token's universal part-of-speech tag.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>morphology</code></td><td class="c-table__cell u-text">dict / <code>None</code></td><td class="c-table__cell u-text"> Morphological features following the <a href="http://universaldependencies.org/" rel="noopener nofollow" target="_blank">Universal Dependencies</a> scheme.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">list</td><td class="c-table__cell u-text">The available lemmas for the string.</td></tr></table>
Lemmatizer.lookup	 Look up a lemma in the lookup table, if available. If no lemma is found,
the original string is returned. Languages can provide a lookup table via the lemma_lookup variable, set on the individual Language class.	<p> Look up a lemma in the lookup table, if available. If no lemma is found,the original string is returned. Languages can provide a <a href="../usage/adding-languages#lemmatizer">lookup table</a> via the <code>lemma_lookup</code> variable, set on the individual <code>Language</code> class.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">lookup = {u'going': u'go'}<br/>lemmatizer = Lemmatizer(lookup=lookup)<br/>assert lemmatizer.lookup(u'going') == u'go'<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>string</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">The string to look up.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">The lemma if the string was found, otherwise the original string.</td></tr></table>
Lemmatizer.is_base_form	 Check whether we're dealing with an uninflected paradigm, so we can
avoid lemmatization entirely.	<p> Check whether we're dealing with an uninflected paradigm, so we canavoid lemmatization entirely.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">pos = 'verb'<br/>morph = {'VerbForm': 'inf'}<br/>is_base_form = lemmatizer.is_base_form(pos, morph)<br/>assert is_base_form == True<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>univ_pos</code></td><td class="c-table__cell u-text">unicode / int</td><td class="c-table__cell u-text">The token's universal part-of-speech tag.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>morphology</code></td><td class="c-table__cell u-text">dict</td><td class="c-table__cell u-text">The token's morphological features.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text"> Whether the token's part-of-speech tag and morphological featuresdescribe a base form.</td></tr></table>
Attributes		<table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>index</code></td><td class="c-table__cell u-text">dict / <code>None</code></td><td class="c-table__cell u-text">Inventory of lemmas in the language.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>exc</code></td><td class="c-table__cell u-text">dict / <code>None</code></td><td class="c-table__cell u-text">Mapping of string forms to lemmas that bypass the <code>rules</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>rules</code></td><td class="c-table__cell u-text">dict / <code>None</code></td><td class="c-table__cell u-text">List of suffix rewrite rules.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>lookup_table</code><div class="u-text-tag u-text-tag--spaced" data-tooltip="This feature is new and was introduced in spaCy v2.0">v2.0 <span aria-role="tooltip" class="u-hidden">This feature is new and was introduced in spaCy v2.0</span></div></td><td class="c-table__cell u-text">dict / <code>None</code></td><td class="c-table__cell u-text">The lemma lookup table, if available.</td></tr></table>
Pipe.Model	 Initialise a model for the pipe. The model should implement the thinc.neural.Model API. Wrappers are under development for most major machine learning libraries.	<p> Initialise a model for the pipe. The model should implement the <code>thinc.neural.Model</code> API. Wrappers are under development for most major machine learning libraries.</p><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>**kwargs</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text">Parameters for initialising the model</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">object</td><td class="c-table__cell u-text">The initialised model.</td></tr></table>
Pipe.__init__	Create a new pipeline instance.	<p>Create a new pipeline instance.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">from spacy.pipeline import Pipe<br/>pipe = Pipe(nlp.vocab)<br/>pipe.from_disk('/path/to/model')<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>vocab</code></td><td class="c-table__cell u-text"><code>Vocab</code></td><td class="c-table__cell u-text">The shared vocabulary.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>model</code></td><td class="c-table__cell u-text"><code>thinc.neural.Model</code> or <code>True</code></td><td class="c-table__cell u-text"> The model powering the pipeline component. If no model issupplied, the model is created when you call <code>begin_training</code>, <code>from_disk</code> or <code>from_bytes</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>**cfg</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text">Configuration parameters.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code>Pipe</code></td><td class="c-table__cell u-text">The newly constructed object.</td></tr></table>
Pipe.__call__	 Apply the pipe to one document. The document is modified in place, and returned. Both Pipe.__call__ and Pipe.pipe should delegate to the Pipe.predict and Pipe.set_annotations methods.	<p> Apply the pipe to one document. The document is modified in place, and returned. Both <code>Pipe.__call__</code> and <code>Pipe.pipe</code> should delegate to the <code>Pipe.predict</code> and <code>Pipe.set_annotations</code> methods.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">pipe = Pipe(nlp.vocab)<br/>doc = nlp(u"This is a sentence.")<br/>processed = pipe(doc)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>doc</code></td><td class="c-table__cell u-text"><code>Doc</code></td><td class="c-table__cell u-text">The document to process.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code>Doc</code></td><td class="c-table__cell u-text">The processed document.</td></tr></table>
Pipe.pipe	 Apply the pipe to a stream of documents. Both Pipe.__call__ and Pipe.pipe should delegate to the Pipe.predict and Pipe.set_annotations methods.	<p> Apply the pipe to a stream of documents. Both <code>Pipe.__call__</code> and <code>Pipe.pipe</code> should delegate to the <code>Pipe.predict</code> and <code>Pipe.set_annotations</code> methods.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">texts = [u'One doc', u'...', u'Lots of docs']<br/>pipe = Pipe(nlp.vocab)<br/>for doc in pipe.pipe(texts, batch_size=50):<br/>    pass<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>stream</code></td><td class="c-table__cell u-text">iterable</td><td class="c-table__cell u-text">A stream of documents.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>batch_size</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">The number of texts to buffer. Defaults to <code>128</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>n_threads</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text"> The number of worker threads to use. If <code>-1</code>, OpenMP will decide how many to use at run time. Default is <code>-1</code>.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">yields</td><td class="c-table__cell u-text"><code>Doc</code></td><td class="c-table__cell u-text">Processed documents in the order of the original text.</td></tr></table>
Pipe.predict	 Apply the pipeline's model to a batch of docs, without modifying them.	<p> Apply the pipeline's model to a batch of docs, without modifying them.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">pipe = Pipe(nlp.vocab)<br/>scores = pipe.predict([doc1, doc2])<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>docs</code></td><td class="c-table__cell u-text">iterable</td><td class="c-table__cell u-text">The documents to predict.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text">Scores from the model.</td></tr></table>
Pipe.set_annotations	 Modify a batch of documents, using pre-computed scores.	<p> Modify a batch of documents, using pre-computed scores.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">pipe = Pipe(nlp.vocab)<br/>scores = pipe.predict([doc1, doc2])<br/>pipe.set_annotations([doc1, doc2], scores)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>docs</code></td><td class="c-table__cell u-text">iterable</td><td class="c-table__cell u-text">The documents to modify.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>scores</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text">The scores to set, produced by <code>Pipe.predict</code>.</td></tr></table>
Pipe.update	 Learn from a batch of documents and gold-standard information, updating the pipe's model. Delegates to Pipe.predict and Pipe.get_loss.	<p> Learn from a batch of documents and gold-standard information, updating the pipe's model. Delegates to <code>Pipe.predict</code> and <code>Pipe.get_loss</code>.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">pipe = Pipe(nlp.vocab)<br/>losses = {}<br/>optimizer = nlp.begin_training()<br/>pipe.update([doc1, doc2], [gold1, gold2], losses=losses, sgd=optimizer)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>docs</code></td><td class="c-table__cell u-text">iterable</td><td class="c-table__cell u-text">A batch of documents to learn from.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>golds</code></td><td class="c-table__cell u-text">iterable</td><td class="c-table__cell u-text">The gold-standard data. Must have the same length as <code>docs</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>drop</code></td><td class="c-table__cell u-text">float</td><td class="c-table__cell u-text">The dropout rate.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>sgd</code></td><td class="c-table__cell u-text">callable</td><td class="c-table__cell u-text"> The optimizer. Should take two arguments <code>weights</code> and <code>gradient</code>, and an optional ID.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>losses</code></td><td class="c-table__cell u-text">dict</td><td class="c-table__cell u-text"> Optional record of the loss during training. The value keyed bythe model's name is updated.</td></tr></table>
Pipe.get_loss	 Find the loss and gradient of loss for the batch of documents and their
predicted scores.	<p> Find the loss and gradient of loss for the batch of documents and theirpredicted scores.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">pipe = Pipe(nlp.vocab)<br/>scores = pipe.predict([doc1, doc2])<br/>loss, d_loss = pipe.get_loss([doc1, doc2], [gold1, gold2], scores)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>docs</code></td><td class="c-table__cell u-text">iterable</td><td class="c-table__cell u-text">The batch of documents.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>golds</code></td><td class="c-table__cell u-text">iterable</td><td class="c-table__cell u-text">The gold-standard data. Must have the same length as <code>docs</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>scores</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text">Scores representing the model's predictions.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">tuple</td><td class="c-table__cell u-text">The loss and the gradient, i.e. <code>(loss, gradient)</code>.</td></tr></table>
Pipe.begin_training	 Initialise the pipe for training, using data exampes if available. If no
model has been initialised yet, the model is added.	<p> Initialise the pipe for training, using data exampes if available. If nomodel has been initialised yet, the model is added.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">pipe = Pipe(nlp.vocab)<br/>nlp.pipeline.append(pipe)<br/>optimizer = pipe.begin_training(pipeline=nlp.pipeline)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>gold_tuples</code></td><td class="c-table__cell u-text">iterable</td><td class="c-table__cell u-text"> Optional gold-standard annotations from which to construct <a class="u-no-border u-inline-block u-nowrap" href="goldparse" target="_self"><code>GoldParse</code> <svg aria-hidden="true" class="o-icon o-icon--inline u-color-theme" height="16" style="min-width: 16px" viewbox="0 0 16 16" width="16"><use xlink:href="#svg_book"></use></svg></a> objects.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>pipeline</code></td><td class="c-table__cell u-text">list</td><td class="c-table__cell u-text"> Optional list of <a class="u-no-border u-inline-block u-nowrap" href="pipe" target="_self"><code>Pipe</code> <svg aria-hidden="true" class="o-icon o-icon--inline u-color-theme" height="16" style="min-width: 16px" viewbox="0 0 16 16" width="16"><use xlink:href="#svg_book"></use></svg></a> components that this component is part of.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>sgd</code></td><td class="c-table__cell u-text">callable</td><td class="c-table__cell u-text"> An optional optimizer. Should take two arguments <code>weights</code> and <code>gradient</code>, and an optional ID. Will be created via <a class="u-no-border u-inline-block u-nowrap" href="pipe#create_optimizer" target="_self"><code>create_optimizer</code> <svg aria-hidden="true" class="o-icon o-icon--inline u-color-theme" height="16" style="min-width: 16px" viewbox="0 0 16 16" width="16"><use xlink:href="#svg_book"></use></svg></a> if not set.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">callable</td><td class="c-table__cell u-text">An optimizer.</td></tr></table>
Pipe.create_optimizer	 Create an optmizer for the pipeline component.	<p> Create an optmizer for the pipeline component.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">pipe = Pipe(nlp.vocab)<br/>optimizer = pipe.create_optimizer()<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">callable</td><td class="c-table__cell u-text">The optimizer.</td></tr></table>
Pipe.use_params	Modify the pipe's model, to use the given parameter values.	<p>Modify the pipe's model, to use the given parameter values.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">pipe = Pipe(nlp.vocab)<br/>with pipe.use_params():<br/>    pipe.to_disk('/best_model')<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>params</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text"> The parameter values to use in the model. At the end of thecontext, the original parameters are restored.</td></tr></table>
Pipe.add_label	Add a new label to the pipe.	<p>Add a new label to the pipe.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">pipe = Pipe(nlp.vocab)<br/>pipe.add_label('MY_LABEL')<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>label</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">The label to add.</td></tr></table>
Pipe.to_disk	Serialize the pipe to disk.	<p>Serialize the pipe to disk.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">pipe = Pipe(nlp.vocab)<br/>pipe.to_disk('/path/to/pipe')<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>path</code></td><td class="c-table__cell u-text">unicode or <code>Path</code></td><td class="c-table__cell u-text"> A path to a directory, which will be created if it doesn't exist. Paths may be either strings or <code>Path</code>-like objects.</td></tr></table>
Pipe.from_disk	Load the pipe from disk. Modifies the object in place and returns it.	<p>Load the pipe from disk. Modifies the object in place and returns it.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">pipe = Pipe(nlp.vocab)<br/>pipe.from_disk('/path/to/pipe')<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>path</code></td><td class="c-table__cell u-text">unicode or <code>Path</code></td><td class="c-table__cell u-text"> A path to a directory. Paths may be either strings or <code>Path</code>-like objects.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code>Pipe</code></td><td class="c-table__cell u-text">The modified <code>Pipe</code> object.</td></tr></table>
Pipe.to_bytes		<aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">pipe = Pipe(nlp.vocab)<br/>pipe_bytes = pipe.to_bytes()<br/></code></pre></div></aside><p>Serialize the pipe to a bytestring.</p><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>**exclude</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text">Named attributes to prevent from being serialized.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">bytes</td><td class="c-table__cell u-text">The serialized form of the <code>Pipe</code> object.</td></tr></table>
Pipe.from_bytes	Load the pipe from a bytestring. Modifies the object in place and returns it.	<p>Load the pipe from a bytestring. Modifies the object in place and returns it.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">pipe_bytes = pipe.to_bytes()<br/>pipe = Pipe(nlp.vocab)<br/>pipe.from_bytes(pipe_bytes)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>bytes_data</code></td><td class="c-table__cell u-text">bytes</td><td class="c-table__cell u-text">The data to load from.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>**exclude</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text">Named attributes to prevent from being loaded.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code>Pipe</code></td><td class="c-table__cell u-text">The <code>Pipe</code> object.</td></tr></table>
EntityRecognizer.Model	 Initialise a model for the pipe. The model should implement the thinc.neural.Model API. Wrappers are under development for most major machine learning libraries.	<p> Initialise a model for the pipe. The model should implement the <code>thinc.neural.Model</code> API. Wrappers are under development for most major machine learning libraries.</p><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>**kwargs</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text">Parameters for initialising the model</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">object</td><td class="c-table__cell u-text">The initialised model.</td></tr></table>
EntityRecognizer.__init__	Create a new pipeline instance.	<p>Create a new pipeline instance.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">from spacy.pipeline import EntityRecognizer<br/>ner = EntityRecognizer(nlp.vocab)<br/>ner.from_disk('/path/to/model')<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>vocab</code></td><td class="c-table__cell u-text"><code>Vocab</code></td><td class="c-table__cell u-text">The shared vocabulary.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>model</code></td><td class="c-table__cell u-text"><code>thinc.neural.Model</code> or <code>True</code></td><td class="c-table__cell u-text"> The model powering the pipeline component. If no model issupplied, the model is created when you call <code>begin_training</code>, <code>from_disk</code> or <code>from_bytes</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>**cfg</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text">Configuration parameters.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code>EntityRecognizer</code></td><td class="c-table__cell u-text">The newly constructed object.</td></tr></table>
EntityRecognizer.__call__	 Apply the pipe to one document. The document is modified in place, and returned. Both EntityRecognizer.__call__ and EntityRecognizer.pipe should delegate to the EntityRecognizer.predict and EntityRecognizer.set_annotations methods.	<p> Apply the pipe to one document. The document is modified in place, and returned. Both <code>EntityRecognizer.__call__</code> and <code>EntityRecognizer.pipe</code> should delegate to the <code>EntityRecognizer.predict</code> and <code>EntityRecognizer.set_annotations</code> methods.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">ner = EntityRecognizer(nlp.vocab)<br/>doc = nlp(u"This is a sentence.")<br/>processed = ner(doc)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>doc</code></td><td class="c-table__cell u-text"><code>Doc</code></td><td class="c-table__cell u-text">The document to process.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code>Doc</code></td><td class="c-table__cell u-text">The processed document.</td></tr></table>
EntityRecognizer.pipe	 Apply the pipe to a stream of documents. Both EntityRecognizer.__call__ and EntityRecognizer.pipe should delegate to the EntityRecognizer.predict and EntityRecognizer.set_annotations methods.	<p> Apply the pipe to a stream of documents. Both <code>EntityRecognizer.__call__</code> and <code>EntityRecognizer.pipe</code> should delegate to the <code>EntityRecognizer.predict</code> and <code>EntityRecognizer.set_annotations</code> methods.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">texts = [u'One doc', u'...', u'Lots of docs']<br/>ner = EntityRecognizer(nlp.vocab)<br/>for doc in ner.pipe(texts, batch_size=50):<br/>    pass<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>stream</code></td><td class="c-table__cell u-text">iterable</td><td class="c-table__cell u-text">A stream of documents.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>batch_size</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">The number of texts to buffer. Defaults to <code>128</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>n_threads</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text"> The number of worker threads to use. If <code>-1</code>, OpenMP will decide how many to use at run time. Default is <code>-1</code>.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">yields</td><td class="c-table__cell u-text"><code>Doc</code></td><td class="c-table__cell u-text">Processed documents in the order of the original text.</td></tr></table>
EntityRecognizer.predict	 Apply the pipeline's model to a batch of docs, without modifying them.	<p> Apply the pipeline's model to a batch of docs, without modifying them.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">ner = EntityRecognizer(nlp.vocab)<br/>scores = ner.predict([doc1, doc2])<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>docs</code></td><td class="c-table__cell u-text">iterable</td><td class="c-table__cell u-text">The documents to predict.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text">Scores from the model.</td></tr></table>
EntityRecognizer.set_annotations	 Modify a batch of documents, using pre-computed scores.	<p> Modify a batch of documents, using pre-computed scores.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">ner = EntityRecognizer(nlp.vocab)<br/>scores = ner.predict([doc1, doc2])<br/>ner.set_annotations([doc1, doc2], scores)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>docs</code></td><td class="c-table__cell u-text">iterable</td><td class="c-table__cell u-text">The documents to modify.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>scores</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text">The scores to set, produced by <code>EntityRecognizer.predict</code>.</td></tr></table>
EntityRecognizer.update	 Learn from a batch of documents and gold-standard information, updating the pipe's model. Delegates to EntityRecognizer.predict and EntityRecognizer.get_loss.	<p> Learn from a batch of documents and gold-standard information, updating the pipe's model. Delegates to <code>EntityRecognizer.predict</code> and <code>EntityRecognizer.get_loss</code>.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">ner = EntityRecognizer(nlp.vocab)<br/>losses = {}<br/>optimizer = nlp.begin_training()<br/>ner.update([doc1, doc2], [gold1, gold2], losses=losses, sgd=optimizer)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>docs</code></td><td class="c-table__cell u-text">iterable</td><td class="c-table__cell u-text">A batch of documents to learn from.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>golds</code></td><td class="c-table__cell u-text">iterable</td><td class="c-table__cell u-text">The gold-standard data. Must have the same length as <code>docs</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>drop</code></td><td class="c-table__cell u-text">float</td><td class="c-table__cell u-text">The dropout rate.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>sgd</code></td><td class="c-table__cell u-text">callable</td><td class="c-table__cell u-text"> The optimizer. Should take two arguments <code>weights</code> and <code>gradient</code>, and an optional ID.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>losses</code></td><td class="c-table__cell u-text">dict</td><td class="c-table__cell u-text"> Optional record of the loss during training. The value keyed bythe model's name is updated.</td></tr></table>
EntityRecognizer.get_loss	 Find the loss and gradient of loss for the batch of documents and their
predicted scores.	<p> Find the loss and gradient of loss for the batch of documents and theirpredicted scores.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">ner = EntityRecognizer(nlp.vocab)<br/>scores = ner.predict([doc1, doc2])<br/>loss, d_loss = ner.get_loss([doc1, doc2], [gold1, gold2], scores)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>docs</code></td><td class="c-table__cell u-text">iterable</td><td class="c-table__cell u-text">The batch of documents.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>golds</code></td><td class="c-table__cell u-text">iterable</td><td class="c-table__cell u-text">The gold-standard data. Must have the same length as <code>docs</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>scores</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text">Scores representing the model's predictions.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">tuple</td><td class="c-table__cell u-text">The loss and the gradient, i.e. <code>(loss, gradient)</code>.</td></tr></table>
EntityRecognizer.begin_training	 Initialise the pipe for training, using data exampes if available. If no
model has been initialised yet, the model is added.	<p> Initialise the pipe for training, using data exampes if available. If nomodel has been initialised yet, the model is added.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">ner = EntityRecognizer(nlp.vocab)<br/>nlp.pipeline.append(ner)<br/>optimizer = ner.begin_training(pipeline=nlp.pipeline)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>gold_tuples</code></td><td class="c-table__cell u-text">iterable</td><td class="c-table__cell u-text"> Optional gold-standard annotations from which to construct <a class="u-no-border u-inline-block u-nowrap" href="goldparse" target="_self"><code>GoldParse</code> <svg aria-hidden="true" class="o-icon o-icon--inline u-color-theme" height="16" style="min-width: 16px" viewbox="0 0 16 16" width="16"><use xlink:href="#svg_book"></use></svg></a> objects.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>pipeline</code></td><td class="c-table__cell u-text">list</td><td class="c-table__cell u-text"> Optional list of <a class="u-no-border u-inline-block u-nowrap" href="pipe" target="_self"><code>Pipe</code> <svg aria-hidden="true" class="o-icon o-icon--inline u-color-theme" height="16" style="min-width: 16px" viewbox="0 0 16 16" width="16"><use xlink:href="#svg_book"></use></svg></a> components that this component is part of.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>sgd</code></td><td class="c-table__cell u-text">callable</td><td class="c-table__cell u-text"> An optional optimizer. Should take two arguments <code>weights</code> and <code>gradient</code>, and an optional ID. Will be created via <a class="u-no-border u-inline-block u-nowrap" href="entityrecognizer#create_optimizer" target="_self"><code>create_optimizer</code> <svg aria-hidden="true" class="o-icon o-icon--inline u-color-theme" height="16" style="min-width: 16px" viewbox="0 0 16 16" width="16"><use xlink:href="#svg_book"></use></svg></a> if not set.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">callable</td><td class="c-table__cell u-text">An optimizer.</td></tr></table>
EntityRecognizer.create_optimizer	 Create an optmizer for the pipeline component.	<p> Create an optmizer for the pipeline component.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">ner = EntityRecognizer(nlp.vocab)<br/>optimizer = ner.create_optimizer()<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">callable</td><td class="c-table__cell u-text">The optimizer.</td></tr></table>
EntityRecognizer.use_params	Modify the pipe's model, to use the given parameter values.	<p>Modify the pipe's model, to use the given parameter values.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">ner = EntityRecognizer(nlp.vocab)<br/>with ner.use_params():<br/>    ner.to_disk('/best_model')<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>params</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text"> The parameter values to use in the model. At the end of thecontext, the original parameters are restored.</td></tr></table>
EntityRecognizer.add_label	Add a new label to the pipe.	<p>Add a new label to the pipe.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">ner = EntityRecognizer(nlp.vocab)<br/>ner.add_label('MY_LABEL')<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>label</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">The label to add.</td></tr></table>
EntityRecognizer.to_disk	Serialize the pipe to disk.	<p>Serialize the pipe to disk.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">ner = EntityRecognizer(nlp.vocab)<br/>ner.to_disk('/path/to/ner')<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>path</code></td><td class="c-table__cell u-text">unicode or <code>Path</code></td><td class="c-table__cell u-text"> A path to a directory, which will be created if it doesn't exist. Paths may be either strings or <code>Path</code>-like objects.</td></tr></table>
EntityRecognizer.from_disk	Load the pipe from disk. Modifies the object in place and returns it.	<p>Load the pipe from disk. Modifies the object in place and returns it.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">ner = EntityRecognizer(nlp.vocab)<br/>ner.from_disk('/path/to/ner')<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>path</code></td><td class="c-table__cell u-text">unicode or <code>Path</code></td><td class="c-table__cell u-text"> A path to a directory. Paths may be either strings or <code>Path</code>-like objects.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code>EntityRecognizer</code></td><td class="c-table__cell u-text">The modified <code>EntityRecognizer</code> object.</td></tr></table>
EntityRecognizer.to_bytes		<aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">ner = EntityRecognizer(nlp.vocab)<br/>ner_bytes = ner.to_bytes()<br/></code></pre></div></aside><p>Serialize the pipe to a bytestring.</p><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>**exclude</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text">Named attributes to prevent from being serialized.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">bytes</td><td class="c-table__cell u-text">The serialized form of the <code>EntityRecognizer</code> object.</td></tr></table>
EntityRecognizer.from_bytes	Load the pipe from a bytestring. Modifies the object in place and returns it.	<p>Load the pipe from a bytestring. Modifies the object in place and returns it.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">ner_bytes = ner.to_bytes()<br/>ner = EntityRecognizer(nlp.vocab)<br/>ner.from_bytes(ner_bytes)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>bytes_data</code></td><td class="c-table__cell u-text">bytes</td><td class="c-table__cell u-text">The data to load from.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>**exclude</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text">Named attributes to prevent from being loaded.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code>EntityRecognizer</code></td><td class="c-table__cell u-text">The <code>EntityRecognizer</code> object.</td></tr></table>
Tokenizer.__init__	Create a Tokenizer, to create Doc objects given unicode text.	<p>Create a <code>Tokenizer</code>, to create <code>Doc</code> objects given unicode text.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content"># Construction 1<br/>from spacy.tokenizer import Tokenizer<br/>tokenizer = Tokenizer(nlp.vocab)<br/><br/># Construction 2<br/>from spacy.lang.en import English<br/>tokenizer = English().Defaults.create_tokenizer(nlp)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>vocab</code></td><td class="c-table__cell u-text"><code>Vocab</code></td><td class="c-table__cell u-text">A storage container for lexical types.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>rules</code></td><td class="c-table__cell u-text">dict</td><td class="c-table__cell u-text">Exceptions and special-cases for the tokenizer.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>prefix_search</code></td><td class="c-table__cell u-text">callable</td><td class="c-table__cell u-text"> A function matching the signature of <code>re.compile(string).search</code> to match prefixes.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>suffix_search</code></td><td class="c-table__cell u-text">callable</td><td class="c-table__cell u-text"> A function matching the signature of <code>re.compile(string).search</code> to match suffixes.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>infix_finditer</code></td><td class="c-table__cell u-text">callable</td><td class="c-table__cell u-text"> A function matching the signature of <code>re.compile(string).finditer</code> to find infixes.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>token_match</code></td><td class="c-table__cell u-text">callable</td><td class="c-table__cell u-text">A boolean function matching strings to be recognised as tokens.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code>Tokenizer</code></td><td class="c-table__cell u-text">The newly constructed object.</td></tr></table>
Tokenizer.__call__	Tokenize a string.	<p>Tokenize a string.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">tokens = tokenizer(u'This is a sentence')<br/>assert len(tokens) == 4<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>string</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">The string to tokenize.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code>Doc</code></td><td class="c-table__cell u-text">A container for linguistic annotations.</td></tr></table>
Tokenizer.pipe	Tokenize a stream of texts.	<p>Tokenize a stream of texts.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">texts = [u'One document.', u'...', u'Lots of documents']<br/>for doc in tokenizer.pipe(texts, batch_size=50):<br/>    pass<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>texts</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text">A sequence of unicode texts.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>batch_size</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">The number of texts to accumulate in an internal buffer.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>n_threads</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text"> The number of threads to use, if the implementation supportsmulti-threading. The default tokenizer is single-threaded.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">yields</td><td class="c-table__cell u-text"><code>Doc</code></td><td class="c-table__cell u-text">A sequence of Doc objects, in order.</td></tr></table>
Tokenizer.find_infix	Find internal split points of the string.	<p>Find internal split points of the string.</p><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>string</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">The string to split.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">list</td><td class="c-table__cell u-text"> A list of <code>re.MatchObject</code> objects that have <code>.start()</code> and <code>.end()</code> methods, denoting the placement of internal segment separators, e.g. hyphens.</td></tr></table>
Tokenizer.find_prefix	 Find the length of a prefix that should be segmented from the string, or None if no prefix rules match.	<p> Find the length of a prefix that should be segmented from the string, or <code>None</code> if no prefix rules match.</p><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>string</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">The string to segment.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">The length of the prefix if present, otherwise <code>None</code>.</td></tr></table>
Tokenizer.find_suffix	 Find the length of a suffix that should be segmented from the string, or None if no suffix rules match.	<p> Find the length of a suffix that should be segmented from the string, or <code>None</code> if no suffix rules match.</p><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>string</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">The string to segment.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">int / <code>None</code></td><td class="c-table__cell u-text">The length of the suffix if present, otherwise <code>None</code>.</td></tr></table>
Tokenizer.add_special_case	 Add a special-case tokenization rule. This mechanism is also used to add
custom tokenizer exceptions to the language data. See the usage guide on adding languages for more details and examples.	<p> Add a special-case tokenization rule. This mechanism is also used to addcustom tokenizer exceptions to the language data. See the usage guide on <a href="../usage/adding-languages#tokenizer-exceptions">adding languages</a> for more details and examples.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">from spacy.attrs import ORTH, LEMMA<br/>case = [{"don't": [{ORTH: "do"}, {ORTH: "n't", LEMMA: "not"}]}]<br/>tokenizer.add_special_case(case)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>string</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">The string to specially tokenize.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>token_attrs</code></td><td class="c-table__cell u-text">iterable</td><td class="c-table__cell u-text"> A sequence of dicts, where each dict describes a token and its attributes. The <code>ORTH</code> fields of the attributes must exactly match the string when they are concatenated.</td></tr></table>
Attributes		<table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>vocab</code></td><td class="c-table__cell u-text"><code>Vocab</code></td><td class="c-table__cell u-text">The vocab object of the parent <code>Doc</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>prefix_search</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text"> A function to find segment boundaries from the start of a string. Returns the length of the segment, or <code>None</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>suffix_search</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text"> A function to find segment boundaries from the end of a string. Returns the length of the segment, or <code>None</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>infix_finditer</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text"> A function to find internal segment separators, e.g. hyphens. Returns a (possibly empty) list of <code>re.MatchObject</code> objects.</td></tr></table>
TextCategorizer.Model	 Initialise a model for the pipe. The model should implement the thinc.neural.Model API. Wrappers are under development for most major machine learning libraries.	<p> Initialise a model for the pipe. The model should implement the <code>thinc.neural.Model</code> API. Wrappers are under development for most major machine learning libraries.</p><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>**kwargs</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text">Parameters for initialising the model</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">object</td><td class="c-table__cell u-text">The initialised model.</td></tr></table>
TextCategorizer.__init__	Create a new pipeline instance.	<p>Create a new pipeline instance.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">from spacy.pipeline import TextCategorizer<br/>textcat = TextCategorizer(nlp.vocab)<br/>textcat.from_disk('/path/to/model')<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>vocab</code></td><td class="c-table__cell u-text"><code>Vocab</code></td><td class="c-table__cell u-text">The shared vocabulary.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>model</code></td><td class="c-table__cell u-text"><code>thinc.neural.Model</code> or <code>True</code></td><td class="c-table__cell u-text"> The model powering the pipeline component. If no model issupplied, the model is created when you call <code>begin_training</code>, <code>from_disk</code> or <code>from_bytes</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>**cfg</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text">Configuration parameters.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code>TextCategorizer</code></td><td class="c-table__cell u-text">The newly constructed object.</td></tr></table>
TextCategorizer.__call__	 Apply the pipe to one document. The document is modified in place, and returned. Both TextCategorizer.__call__ and TextCategorizer.pipe should delegate to the TextCategorizer.predict and TextCategorizer.set_annotations methods.	<p> Apply the pipe to one document. The document is modified in place, and returned. Both <code>TextCategorizer.__call__</code> and <code>TextCategorizer.pipe</code> should delegate to the <code>TextCategorizer.predict</code> and <code>TextCategorizer.set_annotations</code> methods.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">textcat = TextCategorizer(nlp.vocab)<br/>doc = nlp(u"This is a sentence.")<br/>processed = textcat(doc)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>doc</code></td><td class="c-table__cell u-text"><code>Doc</code></td><td class="c-table__cell u-text">The document to process.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code>Doc</code></td><td class="c-table__cell u-text">The processed document.</td></tr></table>
TextCategorizer.pipe	 Apply the pipe to a stream of documents. Both TextCategorizer.__call__ and TextCategorizer.pipe should delegate to the TextCategorizer.predict and TextCategorizer.set_annotations methods.	<p> Apply the pipe to a stream of documents. Both <code>TextCategorizer.__call__</code> and <code>TextCategorizer.pipe</code> should delegate to the <code>TextCategorizer.predict</code> and <code>TextCategorizer.set_annotations</code> methods.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">texts = [u'One doc', u'...', u'Lots of docs']<br/>textcat = TextCategorizer(nlp.vocab)<br/>for doc in textcat.pipe(texts, batch_size=50):<br/>    pass<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>stream</code></td><td class="c-table__cell u-text">iterable</td><td class="c-table__cell u-text">A stream of documents.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>batch_size</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">The number of texts to buffer. Defaults to <code>128</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>n_threads</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text"> The number of worker threads to use. If <code>-1</code>, OpenMP will decide how many to use at run time. Default is <code>-1</code>.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">yields</td><td class="c-table__cell u-text"><code>Doc</code></td><td class="c-table__cell u-text">Processed documents in the order of the original text.</td></tr></table>
TextCategorizer.predict	 Apply the pipeline's model to a batch of docs, without modifying them.	<p> Apply the pipeline's model to a batch of docs, without modifying them.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">textcat = TextCategorizer(nlp.vocab)<br/>scores = textcat.predict([doc1, doc2])<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>docs</code></td><td class="c-table__cell u-text">iterable</td><td class="c-table__cell u-text">The documents to predict.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text">Scores from the model.</td></tr></table>
TextCategorizer.set_annotations	 Modify a batch of documents, using pre-computed scores.	<p> Modify a batch of documents, using pre-computed scores.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">textcat = TextCategorizer(nlp.vocab)<br/>scores = textcat.predict([doc1, doc2])<br/>textcat.set_annotations([doc1, doc2], scores)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>docs</code></td><td class="c-table__cell u-text">iterable</td><td class="c-table__cell u-text">The documents to modify.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>scores</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text">The scores to set, produced by <code>TextCategorizer.predict</code>.</td></tr></table>
TextCategorizer.update	 Learn from a batch of documents and gold-standard information, updating the pipe's model. Delegates to TextCategorizer.predict and TextCategorizer.get_loss.	<p> Learn from a batch of documents and gold-standard information, updating the pipe's model. Delegates to <code>TextCategorizer.predict</code> and <code>TextCategorizer.get_loss</code>.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">textcat = TextCategorizer(nlp.vocab)<br/>losses = {}<br/>optimizer = nlp.begin_training()<br/>textcat.update([doc1, doc2], [gold1, gold2], losses=losses, sgd=optimizer)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>docs</code></td><td class="c-table__cell u-text">iterable</td><td class="c-table__cell u-text">A batch of documents to learn from.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>golds</code></td><td class="c-table__cell u-text">iterable</td><td class="c-table__cell u-text">The gold-standard data. Must have the same length as <code>docs</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>drop</code></td><td class="c-table__cell u-text">float</td><td class="c-table__cell u-text">The dropout rate.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>sgd</code></td><td class="c-table__cell u-text">callable</td><td class="c-table__cell u-text"> The optimizer. Should take two arguments <code>weights</code> and <code>gradient</code>, and an optional ID.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>losses</code></td><td class="c-table__cell u-text">dict</td><td class="c-table__cell u-text"> Optional record of the loss during training. The value keyed bythe model's name is updated.</td></tr></table>
TextCategorizer.get_loss	 Find the loss and gradient of loss for the batch of documents and their
predicted scores.	<p> Find the loss and gradient of loss for the batch of documents and theirpredicted scores.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">textcat = TextCategorizer(nlp.vocab)<br/>scores = textcat.predict([doc1, doc2])<br/>loss, d_loss = textcat.get_loss([doc1, doc2], [gold1, gold2], scores)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>docs</code></td><td class="c-table__cell u-text">iterable</td><td class="c-table__cell u-text">The batch of documents.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>golds</code></td><td class="c-table__cell u-text">iterable</td><td class="c-table__cell u-text">The gold-standard data. Must have the same length as <code>docs</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>scores</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text">Scores representing the model's predictions.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">tuple</td><td class="c-table__cell u-text">The loss and the gradient, i.e. <code>(loss, gradient)</code>.</td></tr></table>
TextCategorizer.begin_training	 Initialise the pipe for training, using data exampes if available. If no
model has been initialised yet, the model is added.	<p> Initialise the pipe for training, using data exampes if available. If nomodel has been initialised yet, the model is added.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">textcat = TextCategorizer(nlp.vocab)<br/>nlp.pipeline.append(textcat)<br/>optimizer = textcat.begin_training(pipeline=nlp.pipeline)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>gold_tuples</code></td><td class="c-table__cell u-text">iterable</td><td class="c-table__cell u-text"> Optional gold-standard annotations from which to construct <a class="u-no-border u-inline-block u-nowrap" href="goldparse" target="_self"><code>GoldParse</code> <svg aria-hidden="true" class="o-icon o-icon--inline u-color-theme" height="16" style="min-width: 16px" viewbox="0 0 16 16" width="16"><use xlink:href="#svg_book"></use></svg></a> objects.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>pipeline</code></td><td class="c-table__cell u-text">list</td><td class="c-table__cell u-text"> Optional list of <a class="u-no-border u-inline-block u-nowrap" href="pipe" target="_self"><code>Pipe</code> <svg aria-hidden="true" class="o-icon o-icon--inline u-color-theme" height="16" style="min-width: 16px" viewbox="0 0 16 16" width="16"><use xlink:href="#svg_book"></use></svg></a> components that this component is part of.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>sgd</code></td><td class="c-table__cell u-text">callable</td><td class="c-table__cell u-text"> An optional optimizer. Should take two arguments <code>weights</code> and <code>gradient</code>, and an optional ID. Will be created via <a class="u-no-border u-inline-block u-nowrap" href="textcategorizer#create_optimizer" target="_self"><code>create_optimizer</code> <svg aria-hidden="true" class="o-icon o-icon--inline u-color-theme" height="16" style="min-width: 16px" viewbox="0 0 16 16" width="16"><use xlink:href="#svg_book"></use></svg></a> if not set.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">callable</td><td class="c-table__cell u-text">An optimizer.</td></tr></table>
TextCategorizer.create_optimizer	 Create an optmizer for the pipeline component.	<p> Create an optmizer for the pipeline component.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">textcat = TextCategorizer(nlp.vocab)<br/>optimizer = textcat.create_optimizer()<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">callable</td><td class="c-table__cell u-text">The optimizer.</td></tr></table>
TextCategorizer.use_params	Modify the pipe's model, to use the given parameter values.	<p>Modify the pipe's model, to use the given parameter values.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">textcat = TextCategorizer(nlp.vocab)<br/>with textcat.use_params():<br/>    textcat.to_disk('/best_model')<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>params</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text"> The parameter values to use in the model. At the end of thecontext, the original parameters are restored.</td></tr></table>
TextCategorizer.add_label	Add a new label to the pipe.	<p>Add a new label to the pipe.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">textcat = TextCategorizer(nlp.vocab)<br/>textcat.add_label('MY_LABEL')<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>label</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">The label to add.</td></tr></table>
TextCategorizer.to_disk	Serialize the pipe to disk.	<p>Serialize the pipe to disk.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">textcat = TextCategorizer(nlp.vocab)<br/>textcat.to_disk('/path/to/textcat')<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>path</code></td><td class="c-table__cell u-text">unicode or <code>Path</code></td><td class="c-table__cell u-text"> A path to a directory, which will be created if it doesn't exist. Paths may be either strings or <code>Path</code>-like objects.</td></tr></table>
TextCategorizer.from_disk	Load the pipe from disk. Modifies the object in place and returns it.	<p>Load the pipe from disk. Modifies the object in place and returns it.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">textcat = TextCategorizer(nlp.vocab)<br/>textcat.from_disk('/path/to/textcat')<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>path</code></td><td class="c-table__cell u-text">unicode or <code>Path</code></td><td class="c-table__cell u-text"> A path to a directory. Paths may be either strings or <code>Path</code>-like objects.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code>TextCategorizer</code></td><td class="c-table__cell u-text">The modified <code>TextCategorizer</code> object.</td></tr></table>
TextCategorizer.to_bytes		<aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">textcat = TextCategorizer(nlp.vocab)<br/>textcat_bytes = textcat.to_bytes()<br/></code></pre></div></aside><p>Serialize the pipe to a bytestring.</p><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>**exclude</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text">Named attributes to prevent from being serialized.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">bytes</td><td class="c-table__cell u-text">The serialized form of the <code>TextCategorizer</code> object.</td></tr></table>
TextCategorizer.from_bytes	Load the pipe from a bytestring. Modifies the object in place and returns it.	<p>Load the pipe from a bytestring. Modifies the object in place and returns it.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">textcat_bytes = textcat.to_bytes()<br/>textcat = TextCategorizer(nlp.vocab)<br/>textcat.from_bytes(textcat_bytes)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>bytes_data</code></td><td class="c-table__cell u-text">bytes</td><td class="c-table__cell u-text">The data to load from.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>**exclude</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text">Named attributes to prevent from being loaded.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code>TextCategorizer</code></td><td class="c-table__cell u-text">The <code>TextCategorizer</code> object.</td></tr></table>
Language.__init__	Initialise a Language object.	<p>Initialise a <code>Language</code> object.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">from spacy.vocab import Vocab<br/>from spacy.language import Language<br/>nlp = Language(Vocab())<br/><br/>from spacy.lang.en import English<br/>nlp = English()<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>vocab</code></td><td class="c-table__cell u-text"><code>Vocab</code></td><td class="c-table__cell u-text"> A <code>Vocab</code> object. If <code>True</code>, a vocab is created via <code>Language.Defaults.create_vocab</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>make_doc</code></td><td class="c-table__cell u-text">callable</td><td class="c-table__cell u-text"> A function that takes text and returns a <code>Doc</code> object. Usually a <code>Tokenizer</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>meta</code></td><td class="c-table__cell u-text">dict</td><td class="c-table__cell u-text"> Custom meta data for the <code>Language</code> class. Is written to by models to add model meta data.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code>Language</code></td><td class="c-table__cell u-text">The newly constructed object.</td></tr></table>
Language.__call__	 Apply the pipeline to some text. The text can span multiple sentences,
and can contain arbtrary whitespace. Alignment into the original string
is preserved.	<p> Apply the pipeline to some text. The text can span multiple sentences,and can contain arbtrary whitespace. Alignment into the original stringis preserved.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">doc = nlp(u'An example sentence. Another sentence.')<br/>assert (doc[0].text, doc[0].head.tag_) == ('An', 'NN')<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>text</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">The text to be processed.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>disable</code></td><td class="c-table__cell u-text">list</td><td class="c-table__cell u-text"> Names of pipeline components to <a href="../usage/processing-pipelines#disabling">disable</a>.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code>Doc</code></td><td class="c-table__cell u-text">A container for accessing the annotations.</td></tr></table><aside class="o-box o-block u-text-small"><h3 class="u-heading u-text-label u-color-theme"><span class="o-emoji">⚠️</span> Changed in v2.0</h3> Pipeline components to prevent from being loaded can now be added as a list to <code>disable</code>, instead of specifying one keyword argument per component.<span class="u-inline-block u-padding-top u-width-full"><pre aria-label="correct" class="c-code-block o-block lang-python c-code-block--has-icon o-block-small" data-language="python"><div class="c-code-block__icon u-color-green c-code-block__icon--border"><svg aria-hidden="true" class="o-icon" height="18" style="min-width: 18px" viewbox="0 0 18 18" width="18"><use xlink:href="#svg_accept"></use></svg></div><code class="c-code-block__content">doc = nlp(u"I don't want parsed", disable=['parser'])</code></pre><pre aria-label="incorrect" class="c-code-block o-block lang-python c-code-block--has-icon o-block-small" data-language="python"><div class="c-code-block__icon u-color-red c-code-block__icon--border"><svg aria-hidden="true" class="o-icon" height="18" style="min-width: 18px" viewbox="0 0 18 18" width="18"><use xlink:href="#svg_reject"></use></svg></div><code class="c-code-block__content">doc = nlp(u"I don't want parsed", parse=False)</code></pre></span></aside>
Language.pipe	 Process texts as a stream, and yield Doc objects in order. Supports GIL-free multi-threading.	<p> Process texts as a stream, and yield <code>Doc</code> objects in order. Supports GIL-free multi-threading.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">texts = [u'One document.', u'...', u'Lots of documents']<br/>for doc in nlp.pipe(texts, batch_size=50, n_threads=4):<br/>    assert doc.is_parsed<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>texts</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text">A sequence of unicode objects.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>as_tuples</code></td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text"> If set to <code>True</code>, inputs should be a sequence of <code>(text, context)</code> tuples. Output will then be a sequence of <code>(doc, context)</code> tuples. Defaults to <code>False</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>n_threads</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text"> The number of worker threads to use. If <code>-1</code>, OpenMP will decide how many to use at run time. Default is <code>2</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>batch_size</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">The number of texts to buffer.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>disable</code></td><td class="c-table__cell u-text">list</td><td class="c-table__cell u-text"> Names of pipeline components to <a href="../usage/processing-pipelines#disabling">disable</a>.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">yields</td><td class="c-table__cell u-text"><code>Doc</code></td><td class="c-table__cell u-text">Documents in the order of the original text.</td></tr></table>
Language.update	Update the models in the pipeline.	<p>Update the models in the pipeline.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">for raw_text, entity_offsets in train_data:<br/>    doc = nlp.make_doc(raw_text)<br/>    gold = GoldParse(doc, entities=entity_offsets)<br/>    nlp.update([doc], [gold], drop=0.5, sgd=optimizer)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>docs</code></td><td class="c-table__cell u-text">iterable</td><td class="c-table__cell u-text"> A batch of <code>Doc</code> objects or unicode. If unicode, a <code>Doc</code> object will be created from the text.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>golds</code></td><td class="c-table__cell u-text">iterable</td><td class="c-table__cell u-text"> A batch of <code>GoldParse</code> objects or dictionaries. Dictionaries will be used to create <a class="u-no-border u-inline-block u-nowrap" href="goldparse" target="_self"><code>GoldParse</code> <svg aria-hidden="true" class="o-icon o-icon--inline u-color-theme" height="16" style="min-width: 16px" viewbox="0 0 16 16" width="16"><use xlink:href="#svg_book"></use></svg></a> objects. For the available keys and their usage, see <a class="u-no-border u-inline-block u-nowrap" href="goldparse#init" target="_self"><code>GoldParse.__init__</code> <svg aria-hidden="true" class="o-icon o-icon--inline u-color-theme" height="16" style="min-width: 16px" viewbox="0 0 16 16" width="16"><use xlink:href="#svg_book"></use></svg></a>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>drop</code></td><td class="c-table__cell u-text">float</td><td class="c-table__cell u-text">The dropout rate.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>sgd</code></td><td class="c-table__cell u-text">callable</td><td class="c-table__cell u-text">An optimizer.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">dict</td><td class="c-table__cell u-text">Results from the update.</td></tr></table>
Language.begin_training	 Allocate models, pre-process training data and acquire an optimizer.	<p> Allocate models, pre-process training data and acquire an optimizer.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">optimizer = nlp.begin_training(gold_tuples)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>gold_tuples</code></td><td class="c-table__cell u-text">iterable</td><td class="c-table__cell u-text">Gold-standard training data.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>**cfg</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text">Config parameters.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">callable</td><td class="c-table__cell u-text">An optimizer.</td></tr></table>
Language.use_params	 Replace weights of models in the pipeline with those provided in the
params dictionary. Can be used as a contextmanager, in which case, models
go back to their original weights after the block.	<p> Replace weights of models in the pipeline with those provided in theparams dictionary. Can be used as a contextmanager, in which case, modelsgo back to their original weights after the block.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">with nlp.use_params(optimizer.averages):<br/>    nlp.to_disk('/tmp/checkpoint')<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>params</code></td><td class="c-table__cell u-text">dict</td><td class="c-table__cell u-text">A dictionary of parameters keyed by model ID.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>**cfg</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text">Config parameters.</td></tr></table>
Language.preprocess_gold	 Can be called before training to pre-process gold data. By default, it
handles nonprojectivity and adds missing tags to the tag map.	<p> Can be called before training to pre-process gold data. By default, ithandles nonprojectivity and adds missing tags to the tag map.</p><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>docs_golds</code></td><td class="c-table__cell u-text">iterable</td><td class="c-table__cell u-text">Tuples of <code>Doc</code> and <code>GoldParse</code> objects.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">yields</td><td class="c-table__cell u-text">tuple</td><td class="c-table__cell u-text">Tuples of <code>Doc</code> and <code>GoldParse</code> objects.</td></tr></table>
Language.create_pipe	Create a pipeline component from a factory.	<p>Create a pipeline component from a factory.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">parser = nlp.create_pipe('parser')<br/>nlp.add_pipe(parser)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>name</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text"> Factory name to look up in <a class="u-no-border u-inline-block u-nowrap" href="language#class-attributes" target="_self"><code>Language.factories</code> <svg aria-hidden="true" class="o-icon o-icon--inline u-color-theme" height="16" style="min-width: 16px" viewbox="0 0 16 16" width="16"><use xlink:href="#svg_book"></use></svg></a>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>config</code></td><td class="c-table__cell u-text">dict</td><td class="c-table__cell u-text">Configuration parameters to initialise component.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">callable</td><td class="c-table__cell u-text">The pipeline component.</td></tr></table>
Language.add_pipe	 Add a component to the processing pipeline. Valid components are callables that take a Doc object, modify it and return it. Only one of before, after, first or last can be set. Default behaviour is last=True.	<p> Add a component to the processing pipeline. Valid components are callables that take a <code>Doc</code> object, modify it and return it. Only one of <code>before</code>, <code>after</code>, <code>first</code> or <code>last</code> can be set. Default behaviour is <code>last=True</code>.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">def component(doc):<br/>    # modify Doc and return it<br/>    return doc<br/><br/>nlp.add_pipe(component, before='ner')<br/>nlp.add_pipe(component, name='custom_name', last=True)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>component</code></td><td class="c-table__cell u-text">callable</td><td class="c-table__cell u-text">The pipeline component.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>name</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text"> Name of pipeline component. Overwrites existing <code>component.name</code> attribute if available. If no <code>name</code> is set and the component exposes no name attribute, <code>component.__name__</code> is used. An error is raised if the name already exists in the pipeline.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>before</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">Component name to insert component directly before.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>after</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">Component name to insert component directly after:</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>first</code></td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text">Insert component first / not first in the pipeline.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>last</code></td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text">Insert component last / not last in the pipeline.</td></tr></table>
Language.has_pipe	 Check whether a component is present in the pipeline. Equivalent to name in nlp.pipe_names.	<p> Check whether a component is present in the pipeline. Equivalent to <code>name in nlp.pipe_names</code>.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">nlp.add_pipe(lambda doc: doc, name='component')<br/>assert 'component' in nlp.pipe_names<br/>assert nlp.has_pipe('component')<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>name</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">Name of the pipeline component to check.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text">Whether a component of that name exists in the pipeline.</td></tr></table>
Language.get_pipe	Get a pipeline component for a given component name.	<p>Get a pipeline component for a given component name.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">parser = nlp.get_pipe('parser')<br/>custom_component = nlp.get_pipe('custom_component')<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>name</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">Name of the pipeline component to get.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">callable</td><td class="c-table__cell u-text">The pipeline component.</td></tr></table>
Language.replace_pipe	Replace a component in the pipeline.	<p>Replace a component in the pipeline.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">nlp.replace_pipe('parser', my_custom_parser)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>name</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">Name of the component to replace.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>component</code></td><td class="c-table__cell u-text">callable</td><td class="c-table__cell u-text">The pipeline component to inser.</td></tr></table>
Language.rename_pipe	 Rename a component in the pipeline. Useful to create custom names for
pre-defined and pre-loaded components. To change the default name of a component added to the pipeline, you can also use the name argument on add_pipe .	<p> Rename a component in the pipeline. Useful to create custom names forpre-defined and pre-loaded components. To change the default name of a component added to the pipeline, you can also use the <code>name</code> argument on <a class="u-no-border u-inline-block u-nowrap" href="language#add_pipe" target="_self"><code>add_pipe</code> <svg aria-hidden="true" class="o-icon o-icon--inline u-color-theme" height="16" style="min-width: 16px" viewbox="0 0 16 16" width="16"><use xlink:href="#svg_book"></use></svg></a>.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">nlp.rename_pipe('parser', 'spacy_parser')<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>old_name</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">Name of the component to rename.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>new_name</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">New name of the component.</td></tr></table>
Language.remove_pipe	 Remove a component from the pipeline. Returns the removed component name
and component function.	<p> Remove a component from the pipeline. Returns the removed component nameand component function.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">name, component = nlp.remove_pipe('parser')<br/>assert name == 'parser'<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>name</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">Name of the component to remove.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">tuple</td><td class="c-table__cell u-text">A <code>(name, component)</code> tuple of the removed component.</td></tr></table>
Language.disable_pipes	 Disable one or more pipeline components. If used as a context manager,
the pipeline will be restored to the initial state at the end of the block. Otherwise, a DisabledPipes object is returned, that has a .restore() method you can use to undo your changes.	<p> Disable one or more pipeline components. If used as a context manager,the pipeline will be restored to the initial state at the end of the block. Otherwise, a <code>DisabledPipes</code> object is returned, that has a <code>.restore()</code> method you can use to undo your changes.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">with nlp.disable_pipes('tagger', 'parser'):<br/>    optimizer = nlp.begin_training(gold_tuples)<br/><br/>disabled = nlp.disable_pipes('tagger', 'parser')<br/>optimizer = nlp.begin_training(gold_tuples)<br/>disabled.restore()<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>*disabled</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">Names of pipeline components to disable.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code>DisabledPipes</code></td><td class="c-table__cell u-text"> The disabled pipes that can be restored by calling the object's <code>.restore()</code> method.</td></tr></table>
Language.to_disk	 Save the current state to a directory. If a model is loaded, this will include the model.	<p> Save the current state to a directory. If a model is loaded, this will <strong>include the model</strong>.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">nlp.to_disk('/path/to/models')<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>path</code></td><td class="c-table__cell u-text">unicode or <code>Path</code></td><td class="c-table__cell u-text"> A path to a directory, which will be created if it doesn't exist. Paths may be either strings or <code>Path</code>-like objects.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>disable</code></td><td class="c-table__cell u-text">list</td><td class="c-table__cell u-text"> Names of pipeline components to <a href="../usage/processing-pipelines#disabling">disable</a> and prevent from being saved.</td></tr></table>
Language.from_disk	 Loads state from a directory. Modifies the object in place and returns it. If the saved Language object contains a model, the model will be loaded.	<p> Loads state from a directory. Modifies the object in place and returns it. If the saved <code>Language</code> object contains a model, the <strong>model will be loaded</strong>.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">from spacy.language import Language<br/>nlp = Language().from_disk('/path/to/models')<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>path</code></td><td class="c-table__cell u-text">unicode or <code>Path</code></td><td class="c-table__cell u-text"> A path to a directory. Paths may be either strings or <code>Path</code>-like objects.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>disable</code></td><td class="c-table__cell u-text">list</td><td class="c-table__cell u-text"> Names of pipeline components to <a href="../usage/processing-pipelines#disabling">disable</a>.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code>Language</code></td><td class="c-table__cell u-text">The modified <code>Language</code> object.</td></tr></table><aside class="o-box o-block u-text-small"><h3 class="u-heading u-text-label u-color-theme"><span class="o-emoji">⚠️</span> Changed in v2.0</h3> As of spaCy v2.0, the <code>save_to_directory</code> method has been renamed to <code>to_disk</code>, to improve consistency across classes. Pipeline components to prevent from being loaded can now be added as a list to <code>disable</code>, instead of specifying one keyword argument per component.<span class="u-inline-block u-padding-top u-width-full"><pre aria-label="correct" class="c-code-block o-block lang-python c-code-block--has-icon o-block-small" data-language="python"><div class="c-code-block__icon u-color-green c-code-block__icon--border"><svg aria-hidden="true" class="o-icon" height="18" style="min-width: 18px" viewbox="0 0 18 18" width="18"><use xlink:href="#svg_accept"></use></svg></div><code class="c-code-block__content">nlp = English().from_disk(disable=['tagger', 'ner'])</code></pre><pre aria-label="incorrect" class="c-code-block o-block lang-python c-code-block--has-icon o-block-small" data-language="python"><div class="c-code-block__icon u-color-red c-code-block__icon--border"><svg aria-hidden="true" class="o-icon" height="18" style="min-width: 18px" viewbox="0 0 18 18" width="18"><use xlink:href="#svg_reject"></use></svg></div><code class="c-code-block__content">nlp = spacy.load('en', tagger=False, entity=False)</code></pre></span></aside>
Language.to_bytes	Serialize the current state to a binary string.	<p>Serialize the current state to a binary string.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">nlp_bytes = nlp.to_bytes()<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>disable</code></td><td class="c-table__cell u-text">list</td><td class="c-table__cell u-text"> Names of pipeline components to <a href="../usage/processing-pipelines#disabling">disable</a> and prevent from being serialized.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">bytes</td><td class="c-table__cell u-text">The serialized form of the <code>Language</code> object.</td></tr></table>
Language.from_bytes	Load state from a binary string.	<p>Load state from a binary string.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">fron spacy.lang.en import English<br/>nlp_bytes = nlp.to_bytes()<br/>nlp2 = English()<br/>nlp2.from_bytes(nlp_bytes)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>bytes_data</code></td><td class="c-table__cell u-text">bytes</td><td class="c-table__cell u-text">The data to load from.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>disable</code></td><td class="c-table__cell u-text">list</td><td class="c-table__cell u-text"> Names of pipeline components to <a href="../usage/processing-pipelines#disabling">disable</a>.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code>Language</code></td><td class="c-table__cell u-text">The <code>Language</code> object.</td></tr></table><aside class="o-box o-block u-text-small"><h3 class="u-heading u-text-label u-color-theme"><span class="o-emoji">⚠️</span> Changed in v2.0</h3> Pipeline components to prevent from being loaded can now be added as a list to <code>disable</code>, instead of specifying one keyword argument per component.<span class="u-inline-block u-padding-top u-width-full"><pre aria-label="correct" class="c-code-block o-block lang-python c-code-block--has-icon o-block-small" data-language="python"><div class="c-code-block__icon u-color-green c-code-block__icon--border"><svg aria-hidden="true" class="o-icon" height="18" style="min-width: 18px" viewbox="0 0 18 18" width="18"><use xlink:href="#svg_accept"></use></svg></div><code class="c-code-block__content">nlp = English().from_bytes(bytes, disable=['tagger', 'ner'])</code></pre><pre aria-label="incorrect" class="c-code-block o-block lang-python c-code-block--has-icon o-block-small" data-language="python"><div class="c-code-block__icon u-color-red c-code-block__icon--border"><svg aria-hidden="true" class="o-icon" height="18" style="min-width: 18px" viewbox="0 0 18 18" width="18"><use xlink:href="#svg_reject"></use></svg></div><code class="c-code-block__content">nlp = English().from_bytes('en', tagger=False, entity=False)</code></pre></span></aside>
Attributes		<table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>vocab</code></td><td class="c-table__cell u-text"><code>Vocab</code></td><td class="c-table__cell u-text">A container for the lexical types.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>tokenizer</code></td><td class="c-table__cell u-text"><code>Tokenizer</code></td><td class="c-table__cell u-text">The tokenizer.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>make_doc</code></td><td class="c-table__cell u-text"><code>lambda text: Doc</code></td><td class="c-table__cell u-text">Create a <code>Doc</code> object from unicode text.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>pipeline</code></td><td class="c-table__cell u-text">list</td><td class="c-table__cell u-text"> List of <code>(name, component)</code> tuples describing the current processing pipeline, in order.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>pipe_names</code><div class="u-text-tag u-text-tag--spaced" data-tooltip="This feature is new and was introduced in spaCy v2.0">v2.0 <span aria-role="tooltip" class="u-hidden">This feature is new and was introduced in spaCy v2.0</span></div></td><td class="c-table__cell u-text">list</td><td class="c-table__cell u-text">List of pipeline component names, in order.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>meta</code></td><td class="c-table__cell u-text">dict</td><td class="c-table__cell u-text"> Custom meta data for the Language class. If a model is loaded,contains meta data of the model.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>path</code><div class="u-text-tag u-text-tag--spaced" data-tooltip="This feature is new and was introduced in spaCy v2.0">v2.0 <span aria-role="tooltip" class="u-hidden">This feature is new and was introduced in spaCy v2.0</span></div></td><td class="c-table__cell u-text"><code>Path</code></td><td class="c-table__cell u-text"> Path to the model data directory, if a model is loaded. Otherwise <code>None</code>.</td></tr></table>
Classattributes		<table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>Defaults</code></td><td class="c-table__cell u-text">class</td><td class="c-table__cell u-text"> Settings, data and factory methods for creating the <code>nlp</code> object and processing pipeline.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>lang</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text"> Two-letter language ID, i.e. <a href="https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes" rel="noopener nofollow" target="_blank">ISO code</a>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>factories</code><div class="u-text-tag u-text-tag--spaced" data-tooltip="This feature is new and was introduced in spaCy v2.0">v2.0 <span aria-role="tooltip" class="u-hidden">This feature is new and was introduced in spaCy v2.0</span></div></td><td class="c-table__cell u-text">dict</td><td class="c-table__cell u-text"> Factories that create pre-defined pipeline components, e.g. thetagger, parser or entity recognizer, keyed by their componentname.</td></tr></table>
Vectors.__init__	 Create a new vector store. You can set the vector values and keys directly on initialisation, or supply a shape keyword argument to create an empty table you can add vectors to later.	<p> Create a new vector store. You can set the vector values and keys directly on initialisation, or supply a <code>shape</code> keyword argument to create an empty table you can add vectors to later.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">from spacy.vectors import Vectors<br/><br/>empty_vectors = Vectors(shape=(10000, 300))<br/><br/>data = numpy.zeros((3, 300), dtype='f')<br/>keys = [u'cat', u'dog', u'rat']<br/>vectors = Vectors(data=data, keys=keys)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>data</code></td><td class="c-table__cell u-text"><code class="u-break">ndarray[ndim=1, dtype='float32']</code></td><td class="c-table__cell u-text">The vector data.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>keys</code></td><td class="c-table__cell u-text">iterable</td><td class="c-table__cell u-text">A sequence of keys aligned with the data.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>shape</code></td><td class="c-table__cell u-text">tuple</td><td class="c-table__cell u-text"> Size of the table as <code>(n_entries, n_columns)</code>, the number of entries and number of columns. Not required if you're initialising the object with <code>data</code> and <code>keys</code>.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code>Vectors</code></td><td class="c-table__cell u-text">The newly created object.</td></tr></table>
Vectors.__getitem__	 Get a vector by key. If the key is not found in the table, a KeyError is raised.	<p> Get a vector by key. If the key is not found in the table, a <code>KeyError</code> is raised.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">cat_id = nlp.vocab.strings[u'cat']<br/>cat_vector = nlp.vocab.vectors[cat_id]<br/>assert cat_vector == nlp.vocab[u'cat'].vector<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>key</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">The key to get the vector for.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code class="u-break">ndarray[ndim=1, dtype='float32']</code></td><td class="c-table__cell u-text">The vector for the key.</td></tr></table>
Vectors.__setitem__	 Set a vector for the given key.	<p> Set a vector for the given key.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">cat_id = nlp.vocab.strings[u'cat']<br/>vector = numpy.random.uniform(-1, 1, (300,))<br/>nlp.vocab.vectors[cat_id] = vector<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>key</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">The key to set the vector for.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>vector</code></td><td class="c-table__cell u-text"><code class="u-break">ndarray[ndim=1, dtype='float32']</code></td><td class="c-table__cell u-text">The vector to set.</td></tr></table>
Vectors.__iter__	Iterate over the keys in the table.	<p>Iterate over the keys in the table.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">for key in nlp.vocab.vectors:<br/>    print(key, nlp.vocab.strings[key])<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">yields</td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">A key in the table.</td></tr></table>
Vectors.__len__	Return the number of vectors in the table.	<p>Return the number of vectors in the table.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">vectors = Vectors(shape=(3, 300))<br/>assert len(vectors) == 3<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">The number of vectors in the table.</td></tr></table>
Vectors.__contains__	 Check whether a key has been mapped to a vector entry in the table.	<p> Check whether a key has been mapped to a vector entry in the table.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">cat_id = nlp.vocab.strings[u'cat']<br/>nlp.vectors.add(cat_id, numpy.random.uniform(-1, 1, (300,)))<br/>assert cat_id in vectors<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>key</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">The key to check.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text">Whether the key has a vector entry.</td></tr></table>
Vectors.add	 Add a key to the table, optionally setting a vector value as well. Keys can be mapped to an existing vector by setting row, or a new vector can be added. When adding unicode keys, keep in mind that the Vectors class itself has no StringStore , so you have to store the hash-to-string mapping separately. If you need to manage the strings, you should use the Vectors via the Vocab  class, e.g. vocab.vectors.	<p> Add a key to the table, optionally setting a vector value as well. Keys can be mapped to an existing vector by setting <code>row</code>, or a new vector can be added. When adding unicode keys, keep in mind that the <code>Vectors</code> class itself has no <a class="u-no-border u-inline-block u-nowrap" href="stringstore" target="_self"><code>StringStore</code> <svg aria-hidden="true" class="o-icon o-icon--inline u-color-theme" height="16" style="min-width: 16px" viewbox="0 0 16 16" width="16"><use xlink:href="#svg_book"></use></svg></a>, so you have to store the hash-to-string mapping separately. If you need to manage the strings, you should use the <code>Vectors</code> via the <a class="u-no-border u-inline-block u-nowrap" href="vocab" target="_self"><code>Vocab</code> <svg aria-hidden="true" class="o-icon o-icon--inline u-color-theme" height="16" style="min-width: 16px" viewbox="0 0 16 16" width="16"><use xlink:href="#svg_book"></use></svg></a> class, e.g. <code>vocab.vectors</code>.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">vector = numpy.random.uniform(-1, 1, (300,))<br/>cat_id = nlp.vocab.strings[u'cat']<br/>nlp.vocab.vectors.add(cat_id, vector=vector)<br/>nlp.vocab.vectors.add(u'dog', row=0)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>key</code></td><td class="c-table__cell u-text">unicode / int</td><td class="c-table__cell u-text">The key to add.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>vector</code></td><td class="c-table__cell u-text"><code class="u-break">ndarray[ndim=1, dtype='float32']</code></td><td class="c-table__cell u-text">An optional vector to add for the key.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>row</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">An optional row number of a vector to map the key to.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">The row the vector was added to.</td></tr></table>
Vectors.resize	 Resize the underlying vectors array. If inplace=True, the memory is reallocated. This may cause other references to the data to become invalid, so only use inplace=True if you're sure that's what you want. If the number of vectors is reduced, keys mapped to rows that have
been deleted are removed. These removed items are returned as a list of (key, row) tuples.	<p> Resize the underlying vectors array. If <code>inplace=True</code>, the memory is reallocated. This may cause other references to the data to become invalid, so only use <code>inplace=True</code> if you're sure that's what you want. If the number of vectors is reduced, keys mapped to rows that havebeen deleted are removed. These removed items are returned as a list of <code>(key, row)</code> tuples.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">removed = nlp.vocab.vectors.resize((10000, 300))<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>shape</code></td><td class="c-table__cell u-text">tuple</td><td class="c-table__cell u-text"> A <code>(rows, dims)</code> tuple describing the number of rows and dimensions.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>inplace</code></td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text">Reallocate the memory.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">list</td><td class="c-table__cell u-text">The removed items as a list of <code>(key, row)</code> tuples.</td></tr></table>
Vectors.keys	A sequence of the keys in the table.	<p>A sequence of the keys in the table.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">for key in nlp.vocab.vectors.keys():<br/>    print(key, nlp.vocab.strings[key])<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">iterable</td><td class="c-table__cell u-text">The keys.</td></tr></table>
Vectors.values	 Iterate over vectors that have been assigned to at least one key. Note
that some vectors may be unassigned, so the number of vectors returned
may be less than the length of the vectors table.	<p> Iterate over vectors that have been assigned to at least one key. Notethat some vectors may be unassigned, so the number of vectors returnedmay be less than the length of the vectors table.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">for vector in nlp.vocab.vectors.values():<br/>    print(vector)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">yields</td><td class="c-table__cell u-text"><code class="u-break">ndarray[ndim=1, dtype='float32']</code></td><td class="c-table__cell u-text">A vector in the table.</td></tr></table>
Vectors.items	Iterate over (key, vector) pairs, in order.	<p>Iterate over <code>(key, vector)</code> pairs, in order.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">for key, vector in nlp.vocab.vectors.items():<br/>    print(key, nlp.vocab.strings[key], vector)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">yields</td><td class="c-table__cell u-text">tuple</td><td class="c-table__cell u-text"><code>(key, vector)</code> pairs, in order.</td></tr></table>
Vectors.shape	 Get (rows, dims) tuples of number of rows and number of dimensions in the vector table.	<p> Get <code>(rows, dims)</code> tuples of number of rows and number of dimensions in the vector table.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">vectors = Vectors(shape(1, 300))<br/>vectors.add(u'cat', numpy.random.uniform(-1, 1, (300,)))<br/>rows, dims = vectors.shape<br/>assert rows == 1<br/>assert dims == 300<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">tuple</td><td class="c-table__cell u-text">A <code>(rows, dims)</code> pair.</td></tr></table>
Vectors.size	The vector size, i.e. rows * dims.	<p>The vector size, i.e. <code>rows * dims</code>.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">vectors = Vectors(shape=(500, 300))<br/>assert vectors.size == 150000<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">The vector size.</td></tr></table>
Vectors.is_full	 Whether the vectors table is full and has no slots are available for new
keys. If a table is full, it can be resized using Vectors.resize .	<p> Whether the vectors table is full and has no slots are available for newkeys. If a table is full, it can be resized using <a class="u-no-border u-inline-block u-nowrap" href="vectors#resize" target="_self"><code>Vectors.resize</code> <svg aria-hidden="true" class="o-icon o-icon--inline u-color-theme" height="16" style="min-width: 16px" viewbox="0 0 16 16" width="16"><use xlink:href="#svg_book"></use></svg></a>.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">vectors = Vectors(shape=(1, 300))<br/>vectors.add(u'cat', numpy.random.uniform(-1, 1, (300,)))<br/>assert vectors.is_full<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text">Whether the vectors table is full.</td></tr></table>
Vectors.n_keys	 Get the number of keys in the table. Note that this is the number of all keys, not just unique vectors. If several keys are mapped are mapped to the same vectors, they will be counted individually.	<p> Get the number of keys in the table. Note that this is the number of <em>all</em> keys, not just unique vectors. If several keys are mapped are mapped to the same vectors, they will be counted individually.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">vectors = Vectors(shape=(10, 300))<br/>assert len(vectors) == 10<br/>assert vectors.n_keys == 0<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">The number of all keys in the table.</td></tr></table>
Vectors.from_glove	 Load GloVe vectors from a directory. Assumes binary format, that the vocab is in a vocab.txt, and that vectors are named vectors.{size}.[fd].bin, e.g. vectors.128.f.bin for 128d float32 vectors, vectors.300.d.bin for 300d float64 (double) vectors, etc. By default GloVe outputs 64-bit vectors.	<p> Load <a href="https://nlp.stanford.edu/projects/glove/" rel="noopener nofollow" target="_blank">GloVe</a> vectors from a directory. Assumes binary format, that the vocab is in a <code>vocab.txt</code>, and that vectors are named <code>vectors.{size}.[fd].bin</code>, e.g. <code>vectors.128.f.bin</code> for 128d float32 vectors, <code>vectors.300.d.bin</code> for 300d float64 (double) vectors, etc. By default GloVe outputs 64-bit vectors.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">vectors = Vectors()<br/>vectors.from_glove('/path/to/glove_vectors')<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>path</code></td><td class="c-table__cell u-text">unicode / <code>Path</code></td><td class="c-table__cell u-text">The path to load the GloVe vectors from.</td></tr></table>
Vectors.to_disk	Save the current state to a directory.	<p>Save the current state to a directory.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">vectors.to_disk('/path/to/vectors')<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>path</code></td><td class="c-table__cell u-text">unicode / <code>Path</code></td><td class="c-table__cell u-text"> A path to a directory, which will be created if it doesn't exist. Paths may be either strings or <code>Path</code>-like objects.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>**exclude</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text">Named attributes to prevent from being saved.</td></tr></table>
Vectors.from_disk	Loads state from a directory. Modifies the object in place and returns it.	<p>Loads state from a directory. Modifies the object in place and returns it.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">vectors = Vectors(StringStore())<br/>vectors.from_disk('/path/to/vectors')<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>path</code></td><td class="c-table__cell u-text">unicode / <code>Path</code></td><td class="c-table__cell u-text"> A path to a directory. Paths may be either strings or <code>Path</code>-like objects.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code>Vectors</code></td><td class="c-table__cell u-text">The modified <code>Vectors</code> object.</td></tr></table>
Vectors.to_bytes	Serialize the current state to a binary string.	<p>Serialize the current state to a binary string.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">vectors_bytes = vectors.to_bytes()<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>**exclude</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text">Named attributes to prevent from being serialized.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">bytes</td><td class="c-table__cell u-text">The serialized form of the <code>Vectors</code> object.</td></tr></table>
Vectors.from_bytes	Load state from a binary string.	<p>Load state from a binary string.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">fron spacy.vectors import Vectors<br/>vectors_bytes = vectors.to_bytes()<br/>new_vectors = Vectors(StringStore())<br/>new_vectors.from_bytes(vectors_bytes)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>data</code></td><td class="c-table__cell u-text">bytes</td><td class="c-table__cell u-text">The data to load from.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>**exclude</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text">Named attributes to prevent from being loaded.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code>Vectors</code></td><td class="c-table__cell u-text">The <code>Vectors</code> object.</td></tr></table>
Attributes		<table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>data</code></td><td class="c-table__cell u-text"><code class="u-break">ndarray[ndim=1, dtype='float32']</code></td><td class="c-table__cell u-text"> Stored vectors data. <code>numpy</code> is used for CPU vectors, <code>cupy</code> for GPU vectors.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>key2row</code></td><td class="c-table__cell u-text">dict</td><td class="c-table__cell u-text"> Dictionary mapping word hashes to rows in the <code>Vectors.data</code> table.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>keys</code></td><td class="c-table__cell u-text"><code class="u-break">ndarray[ndim=1, dtype='float32']</code></td><td class="c-table__cell u-text"> Array keeping the keys in order, such that <code>keys[vectors.key2row[key]] == key</code></td></tr></table>
Vocab.__init__	Create the vocabulary.	<p>Create the vocabulary.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">from spacy.vocab import Vocab<br/>vocab = Vocab(strings=[u'hello', u'world'])<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>lex_attr_getters</code></td><td class="c-table__cell u-text">dict</td><td class="c-table__cell u-text"> A dictionary mapping attribute IDs to functions to compute them. Defaults to <code>None</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>tag_map</code></td><td class="c-table__cell u-text">dict</td><td class="c-table__cell u-text"> A dictionary mapping fine-grained tags to coarse-grainedparts-of-speech, and optionally morphological attributes.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>lemmatizer</code></td><td class="c-table__cell u-text">object</td><td class="c-table__cell u-text">A lemmatizer. Defaults to <code>None</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>strings</code></td><td class="c-table__cell u-text"><code>StringStore</code> or list</td><td class="c-table__cell u-text"> A <a class="u-no-border u-inline-block u-nowrap" href="stringstore" target="_self"><code>StringStore</code> <svg aria-hidden="true" class="o-icon o-icon--inline u-color-theme" height="16" style="min-width: 16px" viewbox="0 0 16 16" width="16"><use xlink:href="#svg_book"></use></svg></a> that maps strings to hash values, and vice versa, or a list of strings.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code>Vocab</code></td><td class="c-table__cell u-text">The newly constructed object.</td></tr></table>
Vocab.__len__	Get the current number of lexemes in the vocabulary.	<p>Get the current number of lexemes in the vocabulary.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">doc = nlp(u'This is a sentence.')<br/>assert len(nlp.vocab) &gt; 0<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">The number of lexems in the vocabulary.</td></tr></table>
Vocab.__getitem__	 Retrieve a lexeme, given an int ID or a unicode string. If a previously
unseen unicode string is given, a new lexeme is created and stored.	<p> Retrieve a lexeme, given an int ID or a unicode string. If a previouslyunseen unicode string is given, a new lexeme is created and stored.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">apple = nlp.vocab.strings['apple']<br/>assert nlp.vocab[apple] == nlp.vocab[u'apple']<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>id_or_string</code></td><td class="c-table__cell u-text">int / unicode</td><td class="c-table__cell u-text">The hash value of a word, or its unicode string.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code>Lexeme</code></td><td class="c-table__cell u-text">The lexeme indicated by the given ID.</td></tr></table>
Vocab.__iter__	Iterate over the lexemes in the vocabulary.	<p>Iterate over the lexemes in the vocabulary.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">stop_words = (lex for lex in nlp.vocab if lex.is_stop)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">yields</td><td class="c-table__cell u-text"><code>Lexeme</code></td><td class="c-table__cell u-text">An entry in the vocabulary.</td></tr></table>
Vocab.__contains__	 Check whether the string has an entry in the vocabulary. To get the ID
for a given string, you need to look it up in vocab.strings .	<p> Check whether the string has an entry in the vocabulary. To get the IDfor a given string, you need to look it up in <a class="u-no-border u-inline-block u-nowrap" href="vocab#attributes" target="_self"><code>vocab.strings</code> <svg aria-hidden="true" class="o-icon o-icon--inline u-color-theme" height="16" style="min-width: 16px" viewbox="0 0 16 16" width="16"><use xlink:href="#svg_book"></use></svg></a>.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">apple = nlp.vocab.strings['apple']<br/>oov = nlp.vocab.strings['dskfodkfos']<br/>assert apple in nlp.vocab<br/>assert oov not in nlp.vocab<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>string</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">The ID string.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text">Whether the string has an entry in the vocabulary.</td></tr></table>
Vocab.add_flag	 Set a new boolean flag to words in the vocabulary. The flag_getter function will be called over the words currently in the vocab, and then
applied to new words as they occur. You'll then be able to access the flag value on each token, using token.check_flag(flag_id).	<p> Set a new boolean flag to words in the vocabulary. The <code>flag_getter</code> function will be called over the words currently in the vocab, and thenapplied to new words as they occur. You'll then be able to access the flag value on each token, using <code>token.check_flag(flag_id)</code>.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">def is_my_product(text):<br/>    products = [u'spaCy', u'Thinc', u'displaCy']<br/>    return text in products<br/><br/>MY_PRODUCT = nlp.vocab.add_flag(is_my_product)<br/>doc = nlp(u'I like spaCy')<br/>assert doc[2].check_flag(MY_PRODUCT) == True<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>flag_getter</code></td><td class="c-table__cell u-text">dict</td><td class="c-table__cell u-text">A function <code>f(unicode) -&gt; bool</code>, to get the flag value.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>flag_id</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text"> An integer between 1 and 63 (inclusive), specifying the bit at which the flag will be stored. If <code>-1</code>, the lowest available bit will be chosen.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">The integer ID by which the flag value can be checked.</td></tr></table>
Vocab.reset_vectors	 Drop the current vector table. Because all vectors must be the same
width, you have to call this to change the size of the vectors. Only one of the width and shape keyword arguments can be specified.	<p> Drop the current vector table. Because all vectors must be the samewidth, you have to call this to change the size of the vectors. Only one of the <code>width</code> and <code>shape</code> keyword arguments can be specified.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">nlp.vocab.reset_vectors(width=300)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>width</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">The new width (keyword argument only).</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>shape</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">The new shape (keyword argument only).</td></tr></table>
Vocab.prune_vectors	 Reduce the current vector table to nr_row unique entries. Words mapped to the discarded vectors will be remapped to the closest vector
among those remaining. For example, suppose the original table had
vectors for the words: ['sat', 'cat', 'feline', 'reclined']. If we prune the vector table to, two rows, we would discard the vectors for "feline"
and "reclined". These words would then be remapped to the closest
remaining vector – so "feline" would have the same vector as "cat",
and "reclined" would have the same vector as "sat". The similarities are
judged by cosine. The original vectors may be large, so the cosines are
calculated in minibatches, to reduce memory usage.	<p> Reduce the current vector table to <code>nr_row</code> unique entries. Words mapped to the discarded vectors will be remapped to the closest vectoramong those remaining. For example, suppose the original table hadvectors for the words: <code class="u-break">['sat', 'cat', 'feline', 'reclined']</code>. If we prune the vector table to, two rows, we would discard the vectors for "feline"and "reclined". These words would then be remapped to the closestremaining vector – so "feline" would have the same vector as "cat",and "reclined" would have the same vector as "sat". The similarities arejudged by cosine. The original vectors may be large, so the cosines arecalculated in minibatches, to reduce memory usage.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">nlp.vocab.prune_vectors(10000)<br/>assert len(nlp.vocab.vectors) &lt;= 1000<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>nr_row</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">The number of rows to keep in the vector table.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>batch_size</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text"> Batch of vectors for calculating the similarities. Larger batchsizes might be faster, while temporarily requiring more memory.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">dict</td><td class="c-table__cell u-text"> A dictionary keyed by removed words mapped to <code>(string, score)</code> tuples, where <code>string</code> is the entry the removed word was mapped to, and <code>score</code> the similarity score between the two words.</td></tr></table>
Vocab.get_vector	 Retrieve a vector for a word in the vocabulary. Words can be looked up
by string or hash value. If no vectors data is loaded, a ValueError is raised.	<p> Retrieve a vector for a word in the vocabulary. Words can be looked upby string or hash value. If no vectors data is loaded, a <code>ValueError</code> is raised.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">nlp.vocab.get_vector(u'apple')<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>orth</code></td><td class="c-table__cell u-text">int / unicode</td><td class="c-table__cell u-text">The hash value of a word, or its unicode string.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code class="u-break">numpy.ndarray[ndim=1, dtype='float32']</code></td><td class="c-table__cell u-text"> A word vector. Size and shape are determined by the <code>Vocab.vectors</code> instance.</td></tr></table>
Vocab.set_vector	 Set a vector for a word in the vocabulary. Words can be referenced by
by string or hash value.	<p> Set a vector for a word in the vocabulary. Words can be referenced byby string or hash value.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">nlp.vocab.set_vector(u'apple', array([...]))<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>orth</code></td><td class="c-table__cell u-text">int / unicode</td><td class="c-table__cell u-text">The hash value of a word, or its unicode string.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>vector</code></td><td class="c-table__cell u-text"><code class="u-break">numpy.ndarray[ndim=1, dtype='float32']</code></td><td class="c-table__cell u-text">The vector to set.</td></tr></table>
Vocab.has_vector	 Check whether a word has a vector. Returns False if no vectors are loaded. Words can be looked up by string or hash value.	<p> Check whether a word has a vector. Returns <code>False</code> if no vectors are loaded. Words can be looked up by string or hash value.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">if nlp.vocab.has_vector(u'apple'):<br/>    vector = nlp.vocab.get_vector(u'apple')<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>orth</code></td><td class="c-table__cell u-text">int / unicode</td><td class="c-table__cell u-text">The hash value of a word, or its unicode string.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text">Whether the word has a vector.</td></tr></table>
Vocab.to_disk	Save the current state to a directory.	<p>Save the current state to a directory.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">nlp.vocab.to_disk('/path/to/vocab')<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>path</code></td><td class="c-table__cell u-text">unicode or <code>Path</code></td><td class="c-table__cell u-text"> A path to a directory, which will be created if it doesn't exist. Paths may be either strings or <code>Path</code>-like objects.</td></tr></table>
Vocab.from_disk	Loads state from a directory. Modifies the object in place and returns it.	<p>Loads state from a directory. Modifies the object in place and returns it.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">from spacy.vocab import Vocab<br/>vocab = Vocab().from_disk('/path/to/vocab')<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>path</code></td><td class="c-table__cell u-text">unicode or <code>Path</code></td><td class="c-table__cell u-text"> A path to a directory. Paths may be either strings or <code>Path</code>-like objects.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code>Vocab</code></td><td class="c-table__cell u-text">The modified <code>Vocab</code> object.</td></tr></table>
Vocab.to_bytes	Serialize the current state to a binary string.	<p>Serialize the current state to a binary string.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">vocab_bytes = nlp.vocab.to_bytes()<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>**exclude</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text">Named attributes to prevent from being serialized.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">bytes</td><td class="c-table__cell u-text">The serialized form of the <code>Vocab</code> object.</td></tr></table>
Vocab.from_bytes	Load state from a binary string.	<p>Load state from a binary string.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">fron spacy.vocab import Vocab<br/>vocab_bytes = nlp.vocab.to_bytes()<br/>vocab = Vocab()<br/>vocab.from_bytes(vocab_bytes)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>bytes_data</code></td><td class="c-table__cell u-text">bytes</td><td class="c-table__cell u-text">The data to load from.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>**exclude</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text">Named attributes to prevent from being loaded.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code>Vocab</code></td><td class="c-table__cell u-text">The <code>Vocab</code> object.</td></tr></table>
Attributes		<aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">apple_id = nlp.vocab.strings['apple']<br/>assert type(apple_id) == int<br/>PERSON = nlp.vocab.strings['PERSON']<br/>assert type(PERSON) == int<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>strings</code></td><td class="c-table__cell u-text"><code>StringStore</code></td><td class="c-table__cell u-text">A table managing the string-to-int mapping.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>vectors</code><div class="u-text-tag u-text-tag--spaced" data-tooltip="This feature is new and was introduced in spaCy v2.0">v2.0 <span aria-role="tooltip" class="u-hidden">This feature is new and was introduced in spaCy v2.0</span></div></td><td class="c-table__cell u-text"><code>Vectors</code></td><td class="c-table__cell u-text">A table associating word IDs to word vectors.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>vectors_length</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">Number of dimensions for each word vector.</td></tr></table>
Matcher.__init__	Create the rule-based Matcher.	<p>Create the rule-based <code>Matcher</code>.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">from spacy.matcher import Matcher<br/><br/>patterns = {'HelloWorld': [{'LOWER': 'hello'}, {'LOWER': 'world'}]}<br/>matcher = Matcher(nlp.vocab)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>vocab</code></td><td class="c-table__cell u-text"><code>Vocab</code></td><td class="c-table__cell u-text"> The vocabulary object, which must be shared with the documentsthe matcher will operate on.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>patterns</code></td><td class="c-table__cell u-text">dict</td><td class="c-table__cell u-text">Patterns to add to the matcher, keyed by ID.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code>Matcher</code></td><td class="c-table__cell u-text">The newly constructed object.</td></tr></table>
Matcher.__call__	Find all token sequences matching the supplied patterns on the Doc.	<p>Find all token sequences matching the supplied patterns on the <code>Doc</code>.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">from spacy.matcher import Matcher<br/><br/>matcher = Matcher(nlp.vocab)<br/>pattern = [{'LOWER': "hello"}, {'LOWER': "world"}]<br/>matcher.add("HelloWorld", None, pattern)<br/>doc = nlp(u'hello world!')<br/>matches = matcher(doc)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>doc</code></td><td class="c-table__cell u-text"><code>Doc</code></td><td class="c-table__cell u-text">The document to match over.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">list</td><td class="c-table__cell u-text"> A list of <code>(match_id, start, end)</code> tuples, describing the matches. A match tuple describes a span <code>doc[start:end]</code>. The <code>match_id</code> is the ID of the added match pattern.</td></tr></table><aside class="o-box o-block u-text-small"><h3 class="u-heading u-text-label u-color-theme"> Important note</h3> By default, the matcher <strong>does not perform any action</strong> on matches, like tagging matched phrases with entity types. Instead, actions need to be specified when <strong>adding patterns or entities</strong>, by passing in a callback function as the <code>on_match</code> argument on <a class="u-no-border u-inline-block u-nowrap" href="matcher#add" target="_self"><code>add</code> <svg aria-hidden="true" class="o-icon o-icon--inline u-color-theme" height="16" style="min-width: 16px" viewbox="0 0 16 16" width="16"><use xlink:href="#svg_book"></use></svg></a>. This allows you to define custom actions per pattern within the same matcher. For example, you might onlywant to merge some entity types, and set custom flags for other matchedpatterns. For more details and examples, see the usage guide on <a href="../usage/linguistic-features#rule-based-matching">rule-based matching</a>.</aside>
Matcher.pipe	Match a stream of documents, yielding them in turn.	<p>Match a stream of documents, yielding them in turn.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">from spacy.matcher import Matcher<br/>matcher = Matcher(nlp.vocab)<br/>for doc in matcher.pipe(docs, batch_size=50, n_threads=4):<br/>    pass<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>docs</code></td><td class="c-table__cell u-text">iterable</td><td class="c-table__cell u-text">A stream of documents.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>batch_size</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">The number of documents to accumulate into a working set.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>n_threads</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text"> The number of threads with which to work on the buffer in parallel, if the <code>Matcher</code> implementation supports multi-threading.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>return_matches</code><div class="u-text-tag u-text-tag--spaced" data-tooltip="This feature is new and was introduced in spaCy v2.1">v2.1 <span aria-role="tooltip" class="u-hidden">This feature is new and was introduced in spaCy v2.1</span></div></td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text"> Yield the match lists along with the docs, making results <code>(doc, matches)</code> tuples.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>as_tuples</code><div class="u-text-tag u-text-tag--spaced" data-tooltip="This feature is new and was introduced in spaCy v2.1">v2.1 <span aria-role="tooltip" class="u-hidden">This feature is new and was introduced in spaCy v2.1</span></div></td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text"> Interpret the input stream as <code>(doc, context)</code> tuples, and yield <code>(result, context)</code> tuples out. If both <code>return_matches</code> and <code>as_tuples</code> are <code>True</code>, the output will be a sequence of <code>((doc, matches), context)</code> tuples.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">yields</td><td class="c-table__cell u-text"><code>Doc</code></td><td class="c-table__cell u-text">Documents, in order.</td></tr></table>
Matcher.__len__	 Get the number of rules added to the matcher. Note that this only returns
the number of rules (identical with the number of IDs), not the number
of individual patterns.	<p> Get the number of rules added to the matcher. Note that this only returnsthe number of rules (identical with the number of IDs), not the numberof individual patterns.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">matcher = Matcher(nlp.vocab)<br/>assert len(matcher) == 0<br/>matcher.add('Rule', None, [{'ORTH': 'test'}])<br/>assert len(matcher) == 1<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">The number of rules.</td></tr></table>
Matcher.__contains__	Check whether the matcher contains rules for a match ID.	<p>Check whether the matcher contains rules for a match ID.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">matcher = Matcher(nlp.vocab)<br/>assert 'Rule' not in matcher<br/>matcher.add('Rule', None, [{'ORTH': 'test'}])<br/>assert 'Rule' in matcher<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>key</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">The match ID.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">Whether the matcher contains rules for this match ID.</td></tr></table>
Matcher.add	 Add a rule to the matcher, consisting of an ID key, one or more patterns, and
a callback function to act on the matches. The callback function will receive the arguments matcher, doc, i and matches. If a pattern already exists for the given ID, the patterns will be extended. An on_match callback will be overwritten.	<p> Add a rule to the matcher, consisting of an ID key, one or more patterns, anda callback function to act on the matches. The callback function will receive the arguments <code>matcher</code>, <code>doc</code>, <code>i</code> and <code>matches</code>. If a pattern already exists for the given ID, the patterns will be extended. An <code>on_match</code> callback will be overwritten.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">def on_match(matcher, doc, id, matches):<br/>    print('Matched!', matches)<br/><br/>matcher = Matcher(nlp.vocab)<br/>matcher.add('HelloWorld', on_match, [{'LOWER': 'hello'}, {'LOWER': 'world'}])<br/>matcher.add('GoogleMaps', on_match, [{'ORTH': 'Google'}, {'ORTH': 'Maps'}])<br/>doc = nlp(u'HELLO WORLD on Google Maps.')<br/>matches = matcher(doc)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>match_id</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">An ID for the thing you're matching.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>on_match</code></td><td class="c-table__cell u-text">callable or <code>None</code></td><td class="c-table__cell u-text"> Callback function to act on matches. Takes the arguments <code>matcher</code>, <code>doc</code>, <code>i</code> and <code>matches</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>*patterns</code></td><td class="c-table__cell u-text">list</td><td class="c-table__cell u-text"> Match pattern. A pattern consists of a list of dicts, where eachdict describes a token.</td></tr></table><aside class="o-box o-block u-text-small"><h3 class="u-heading u-text-label u-color-theme"><span class="o-emoji">⚠️</span> Changed in v2.0</h3> As of spaCy 2.0, <code>Matcher.add_pattern</code> and <code>Matcher.add_entity</code> are deprecated and have been replaced with a simpler <a class="u-no-border u-inline-block u-nowrap" href="matcher#add" target="_self"><code>Matcher.add</code> <svg aria-hidden="true" class="o-icon o-icon--inline u-color-theme" height="16" style="min-width: 16px" viewbox="0 0 16 16" width="16"><use xlink:href="#svg_book"></use></svg></a> that lets you add a list of patterns and a callback for a given match ID.<span class="u-inline-block u-padding-top u-width-full"><pre aria-label="correct" class="c-code-block o-block lang-python c-code-block--has-icon o-block-small" data-language="python"><div class="c-code-block__icon u-color-green c-code-block__icon--border"><svg aria-hidden="true" class="o-icon" height="18" style="min-width: 18px" viewbox="0 0 18 18" width="18"><use xlink:href="#svg_accept"></use></svg></div><code class="c-code-block__content">matcher.add('GoogleNow', merge_phrases, [{ORTH: 'Google'}, {ORTH: 'Now'}])<br/></code></pre><pre aria-label="incorrect" class="c-code-block o-block lang-python c-code-block--has-icon o-block-small" data-language="python"><div class="c-code-block__icon u-color-red c-code-block__icon--border"><svg aria-hidden="true" class="o-icon" height="18" style="min-width: 18px" viewbox="0 0 18 18" width="18"><use xlink:href="#svg_reject"></use></svg></div><code class="c-code-block__content">matcher.add_entity('GoogleNow', on_match=merge_phrases)<br/>matcher.add_pattern('GoogleNow', [{ORTH: 'Google'}, {ORTH: 'Now'}])<br/></code></pre></span></aside>
Matcher.remove	 Remove a rule from the matcher. A KeyError is raised if the match ID does not exist.	<p> Remove a rule from the matcher. A <code>KeyError</code> is raised if the match ID does not exist.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">matcher.add('Rule', None, [{'ORTH': 'test'}])<br/>assert 'Rule' in matcher<br/>matcher.remove('Rule')<br/>assert 'Rule' not in matcher<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>key</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">The ID of the match rule.</td></tr></table>
Matcher.get	 Retrieve the pattern stored for a key. Returns the rule as an (on_match, patterns) tuple containing the callback and available patterns.	<p> Retrieve the pattern stored for a key. Returns the rule as an <code>(on_match, patterns)</code> tuple containing the callback and available patterns.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">pattern = [{'ORTH': 'test'}]<br/>matcher.add('Rule', None, pattern)<br/>on_match, patterns = matcher.get('Rule')<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>key</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">The ID of the match rule.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">tuple</td><td class="c-table__cell u-text">The rule, as an <code>(on_match, patterns)</code> tuple.</td></tr></table>
StringStore.__init__	 Create the StringStore.	<p> Create the <code>StringStore</code>.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">from spacy.strings import StringStore<br/>stringstore = StringStore([u'apple', u'orange'])<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>strings</code></td><td class="c-table__cell u-text">iterable</td><td class="c-table__cell u-text">A sequence of unicode strings to add to the store.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code>StringStore</code></td><td class="c-table__cell u-text">The newly constructed object.</td></tr></table>
StringStore.__len__	Get the number of strings in the store.	<p>Get the number of strings in the store.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">stringstore = StringStore([u'apple', u'orange'])<br/>assert len(stringstore) == 2<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">The number of strings in the store.</td></tr></table>
StringStore.__getitem__	Retrieve a string from a given hash, or vice versa.	<p>Retrieve a string from a given hash, or vice versa.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">stringstore = StringStore([u'apple', u'orange'])<br/>apple_hash = stringstore[u'apple']<br/>assert apple_hash == 8566208034543834098<br/>assert stringstore[apple_hash] == u'apple'<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>string_or_id</code></td><td class="c-table__cell u-text">bytes, unicode or uint64</td><td class="c-table__cell u-text">The value to encode.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">unicode or int</td><td class="c-table__cell u-text">The value to be retrieved.</td></tr></table>
StringStore.__contains__	Check whether a string is in the store.	<p>Check whether a string is in the store.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">stringstore = StringStore([u'apple', u'orange'])<br/>assert u'apple' in stringstore<br/>assert not u'cherry' in stringstore<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>string</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">The string to check.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text">Whether the store contains the string.</td></tr></table>
StringStore.__iter__	 Iterate over the strings in the store, in order. Note that a newly initialised store will always include an empty string '' at position 0.	<p> Iterate over the strings in the store, in order. Note that a newly initialised store will always include an empty string <code>''</code> at position <code>0</code>.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">stringstore = StringStore([u'apple', u'orange'])<br/>all_strings = [s for s in stringstore]<br/>assert all_strings == [u'apple', u'orange']<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">yields</td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">A string in the store.</td></tr></table>
StringStore.add	Add a string to the StringStore.	<p>Add a string to the <code>StringStore</code>.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">stringstore = StringStore([u'apple', u'orange'])<br/>banana_hash = stringstore.add(u'banana')<br/>assert len(stringstore) == 3<br/>assert banana_hash == 2525716904149915114<br/>assert stringstore[banana_hash] == u'banana'<br/>assert stringstore[u'banana'] == banana_hash<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>string</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">The string to add.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">uint64</td><td class="c-table__cell u-text">The string's hash value.</td></tr></table>
StringStore.to_disk	Save the current state to a directory.	<p>Save the current state to a directory.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">stringstore.to_disk('/path/to/strings')<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>path</code></td><td class="c-table__cell u-text">unicode or <code>Path</code></td><td class="c-table__cell u-text"> A path to a directory, which will be created if it doesn't exist. Paths may be either strings or <code>Path</code>-like objects.</td></tr></table>
StringStore.from_disk	Loads state from a directory. Modifies the object in place and returns it.	<p>Loads state from a directory. Modifies the object in place and returns it.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">from spacy.strings import StringStore<br/>stringstore = StringStore().from_disk('/path/to/strings')<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>path</code></td><td class="c-table__cell u-text">unicode or <code>Path</code></td><td class="c-table__cell u-text"> A path to a directory. Paths may be either strings or <code>Path</code>-like objects.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code>StringStore</code></td><td class="c-table__cell u-text">The modified <code>StringStore</code> object.</td></tr></table>
StringStore.to_bytes	Serialize the current state to a binary string.	<p>Serialize the current state to a binary string.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">store_bytes = stringstore.to_bytes()<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>**exclude</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text">Named attributes to prevent from being serialized.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">bytes</td><td class="c-table__cell u-text">The serialized form of the <code>StringStore</code> object.</td></tr></table>
StringStore.from_bytes	Load state from a binary string.	<p>Load state from a binary string.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">fron spacy.strings import StringStore<br/>store_bytes = stringstore.to_bytes()<br/>new_store = StringStore().from_bytes(store_bytes)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>bytes_data</code></td><td class="c-table__cell u-text">bytes</td><td class="c-table__cell u-text">The data to load from.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>**exclude</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text">Named attributes to prevent from being loaded.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code>StringStore</code></td><td class="c-table__cell u-text">The <code>StringStore</code> object.</td></tr></table>
Utilities	Get a 64-bit hash for a given string.	<h3 class="u-heading-3 u-heading" id="hash_string"><a class="u-permalink" href="stringstore#hash_string">strings.hash_string<div class="u-text-tag u-text-tag--spaced">function</div></a></h3><p>Get a 64-bit hash for a given string.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">from spacy.strings import hash_string<br/>assert hash_string(u'apple') == 8566208034543834098<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>string</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">The string to hash.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">uint64</td><td class="c-table__cell u-text">The hash.</td></tr></table>
Span.__init__	Create a Span object from the slice doc[start : end].	<p>Create a Span object from the <code>slice doc[start : end]</code>.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">doc = nlp(u'Give it back! He pleaded.')<br/>span = doc[1:4]<br/>assert [t.text for t in span] ==  [u'it', u'back', u'!']<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>doc</code></td><td class="c-table__cell u-text"><code>Doc</code></td><td class="c-table__cell u-text">The parent document.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>start</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">The index of the first token of the span.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>end</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">The index of the first token after the span.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>label</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">A label to attach to the span, e.g. for named entities.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>vector</code></td><td class="c-table__cell u-text"><code class="u-break">numpy.ndarray[ndim=1, dtype='float32']</code></td><td class="c-table__cell u-text">A meaning representation of the span.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code>Span</code></td><td class="c-table__cell u-text">The newly constructed object.</td></tr></table>
Span.__getitem__	Get a Token object.	<p>Get a <code>Token</code> object.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">doc = nlp(u'Give it back! He pleaded.')<br/>span = doc[1:4]<br/>assert span[1].text == 'back'<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>i</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">The index of the token within the span.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code>Token</code></td><td class="c-table__cell u-text">The token at <code>span[i]</code>.</td></tr></table><p>Get a <code>Span</code> object.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">doc = nlp(u'Give it back! He pleaded.')<br/>span = doc[1:4]<br/>assert span[1:3].text == 'back!'<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>start_end</code></td><td class="c-table__cell u-text">tuple</td><td class="c-table__cell u-text">The slice of the span to get.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code>Span</code></td><td class="c-table__cell u-text">The span at <code>span[start : end]</code>.</td></tr></table>
Span.__iter__	Iterate over Token objects.	<p>Iterate over <code>Token</code> objects.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">doc = nlp(u'Give it back! He pleaded.')<br/>span = doc[1:4]<br/>assert [t.text for t in span] == ['it', 'back', '!']<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">yields</td><td class="c-table__cell u-text"><code>Token</code></td><td class="c-table__cell u-text">A <code>Token</code> object.</td></tr></table>
Span.__len__	Get the number of tokens in the span.	<p>Get the number of tokens in the span.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">doc = nlp(u'Give it back! He pleaded.')<br/>span = doc[1:4]<br/>assert len(span) == 3<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">The number of tokens in the span.</td></tr></table>
Span.set_extension	 Define a custom attribute on the Span which becomes available via Span._. For details, see the documentation on custom attributes.	<p> Define a custom attribute on the <code>Span</code> which becomes available via <code>Span._</code>. For details, see the documentation on <a href="../usage/processing-pipelines#custom-components-attributes">custom attributes</a>.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">from spacy.tokens import Span<br/>city_getter = lambda span: any(city in span.text for city in ('New York', 'Paris', 'Berlin'))<br/>Span.set_extension('has_city', getter=city_getter)<br/>doc = nlp(u'I like New York in Autumn')<br/>assert doc[1:4]._.has_city<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>name</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text"> Name of the attribute to set by the extension. For example, <code>'my_attr'</code> will be available as <code>span._.my_attr</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>default</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text"> Optional default value of the attribute if no getter or methodis defined.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>method</code></td><td class="c-table__cell u-text">callable</td><td class="c-table__cell u-text"> Set a custom method on the object, for example <code>span._.compare(other_span)</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>getter</code></td><td class="c-table__cell u-text">callable</td><td class="c-table__cell u-text"> Getter function that takes the object and returns an attribute value. Is called when the user accesses the <code>._</code> attribute.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>setter</code></td><td class="c-table__cell u-text">callable</td><td class="c-table__cell u-text"> Setter function that takes the <code>Span</code> and a value, and modifies the object. Is called when the user writes to the <code>Span._</code> attribute.</td></tr></table>
Span.get_extension	 Look up a previously registered extension by name. Returns a 4-tuple (default, method, getter, setter) if the extension is registered. Raises a KeyError otherwise.	<p> Look up a previously registered extension by name. Returns a 4-tuple <code class="u-break">(default, method, getter, setter)</code> if the extension is registered. Raises a <code>KeyError</code> otherwise.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">from spacy.tokens import Span<br/>Span.set_extension('is_city', default=False)<br/>extension = Span.get_extension('is_city')<br/>assert extension == (False, None, None, None)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>name</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">Name of the extension.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">tuple</td><td class="c-table__cell u-text"> A <code class="u-break">(default, method, getter, setter)</code> tuple of the extension.</td></tr></table>
Span.has_extension	Check whether an extension has been registered on the Span class.	<p>Check whether an extension has been registered on the <code>Span</code> class.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">from spacy.tokens import Span<br/>Span.set_extension('is_city', default=False)<br/>assert Span.has_extension('is_city')<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>name</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">Name of the extension to check.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text">Whether the extension has been registered.</td></tr></table>
Span.similarity	 Make a semantic similarity estimate. The default estimate is cosine
similarity using an average of word vectors.	<p> Make a semantic similarity estimate. The default estimate is cosinesimilarity using an average of word vectors.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">doc = nlp(u'green apples and red oranges')<br/>green_apples = doc[:2]<br/>red_oranges = doc[3:]<br/>apples_oranges = green_apples.similarity(red_oranges)<br/>oranges_apples = red_oranges.similarity(green_apples)<br/>assert apples_oranges == oranges_apples<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>other</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text"> The object to compare with. By default, accepts <code>Doc</code>, <code>Span</code>, <code>Token</code> and <code>Lexeme</code> objects.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">float</td><td class="c-table__cell u-text">A scalar similarity score. Higher is more similar.</td></tr></table>
Span.get_lca_matrix	 Calculates the lowest common ancestor matrix for a given Span. Returns LCA matrix containing the integer index of the ancestor, or -1 if no common ancestor is found, e.g. if span excludes a necessary ancestor.	<p> Calculates the lowest common ancestor matrix for a given <code>Span</code>. Returns LCA matrix containing the integer index of the ancestor, or <code>-1</code> if no common ancestor is found, e.g. if span excludes a necessary ancestor.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">doc = nlp(u'I like New York in Autumn')<br/>span = doc[1:4]<br/>matrix = span.get_lca_matrix()<br/># array([[0, 0, 0], [0, 1, 2], [0, 2, 2]], dtype=int32)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code class="u-break">numpy.ndarray[ndim=2, dtype='int32']</code></td><td class="c-table__cell u-text">The lowest common ancestor matrix of the <code>Span</code>.</td></tr></table>
Span.to_array	 Given a list of M attribute IDs, export the tokens to a numpy ndarray of shape (N, M), where N is the length of the document. The values will be 32-bit integers.	<p> Given a list of <code>M</code> attribute IDs, export the tokens to a numpy <code>ndarray</code> of shape <code>(N, M)</code>, where <code>N</code> is the length of the document. The values will be 32-bit integers.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">from spacy.attrs import LOWER, POS, ENT_TYPE, IS_ALPHA<br/>doc = nlp(u'I like New York in Autumn.')<br/>span = doc[2:3]<br/># All strings mapped to integers, for easy export to numpy<br/>np_array = span.to_array([LOWER, POS, ENT_TYPE, IS_ALPHA])<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>attr_ids</code></td><td class="c-table__cell u-text">list</td><td class="c-table__cell u-text">A list of attribute ID ints.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code class="u-break">numpy.ndarray[long, ndim=2]</code></td><td class="c-table__cell u-text"> A feature matrix, with one row per word, and one column per attribute indicated in the input <code>attr_ids</code>.</td></tr></table>
Span.merge	Retokenize the document, such that the span is merged into a single token.	<p>Retokenize the document, such that the span is merged into a single token.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">doc = nlp(u'I like New York in Autumn.')<br/>span = doc[2:4]<br/>span.merge()<br/>assert len(doc) == 6<br/>assert doc[2].text == 'New York'<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>**attributes</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text"> Attributes to assign to the merged token. By default, attributesare inherited from the syntactic root token of the span.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code>Token</code></td><td class="c-table__cell u-text">The newly merged token.</td></tr></table>
Span.as_doc	 Create a Doc object view of the Span's data. Mostly useful for C-typed interfaces.	<p> Create a <code>Doc</code> object view of the <code>Span</code>'s data. Mostly useful for C-typed interfaces.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">doc = nlp(u'I like New York in Autumn.')<br/>span = doc[2:4]<br/>doc2 = span.as_doc()<br/>assert doc2.text == 'New York'<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code>Doc</code></td><td class="c-table__cell u-text">A <code>Doc</code> object of the <code>Span</code>'s content.</td></tr></table>
Span.root	 The token within the span that's highest in the parse tree. If there's a
tie, the earliest is preferred.	<p> The token within the span that's highest in the parse tree. If there's atie, the earliest is preferred.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">doc = nlp(u'I like New York in Autumn.')<br/>i, like, new, york, in_, autumn, dot = range(len(doc))<br/>assert doc[new].head.text == 'York'<br/>assert doc[york].head.text == 'like'<br/>new_york = doc[new:york+1]<br/>assert new_york.root.text == 'York'<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code>Token</code></td><td class="c-table__cell u-text">The root token.</td></tr></table>
Span.lefts	Tokens that are to the left of the span, whose heads are within the span.	<p>Tokens that are to the left of the span, whose heads are within the span.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">doc = nlp(u'I like New York in Autumn.')<br/>lefts = [t.text for t in doc[3:7].lefts]<br/>assert lefts == [u'New']<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">yields</td><td class="c-table__cell u-text"><code>Token</code></td><td class="c-table__cell u-text">A left-child of a token of the span.</td></tr></table>
Span.rights	Tokens that are to the right of the span, whose heads are within the span.	<p>Tokens that are to the right of the span, whose heads are within the span.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">doc = nlp(u'I like New York in Autumn.')<br/>rights = [t.text for t in doc[2:4].rights]<br/>assert rights == [u'in']<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">yields</td><td class="c-table__cell u-text"><code>Token</code></td><td class="c-table__cell u-text">A right-child of a token of the span.</td></tr></table>
Span.n_lefts	 The number of tokens that are to the left of the span, whose heads are
within the span.	<p> The number of tokens that are to the left of the span, whose heads arewithin the span.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">doc = nlp(u'I like New York in Autumn.')<br/>assert doc[3:7].n_lefts == 1<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">The number of left-child tokens.</td></tr></table>
Span.n_rights	 The number of tokens that are to the right of the span, whose heads are
within the span.	<p> The number of tokens that are to the right of the span, whose heads arewithin the span.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">doc = nlp(u'I like New York in Autumn.')<br/>assert doc[2:4].n_rights == 1<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">The number of right-child tokens.</td></tr></table>
Span.subtree	Tokens that descend from tokens in the span, but fall outside it.	<p>Tokens that descend from tokens in the span, but fall outside it.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">doc = nlp(u'Give it back! He pleaded.')<br/>subtree = [t.text for t in doc[:3].subtree]<br/>assert subtree == [u'Give', u'it', u'back', u'!']<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">yields</td><td class="c-table__cell u-text"><code>Token</code></td><td class="c-table__cell u-text">A descendant of a token within the span.</td></tr></table>
Span.has_vector	 A boolean value indicating whether a word vector is associated with the
object.	<p> A boolean value indicating whether a word vector is associated with theobject.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">doc = nlp(u'I like apples')<br/>assert doc[1:].has_vector<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text">Whether the span has a vector data attached.</td></tr></table>
Span.vector	 A real-valued meaning representation. Defaults to an average of the
token vectors.	<p> A real-valued meaning representation. Defaults to an average of thetoken vectors.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">doc = nlp(u'I like apples')<br/>assert doc[1:].vector.dtype == 'float32'<br/>assert doc[1:].vector.shape == (300,)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code class="u-break">numpy.ndarray[ndim=1, dtype='float32']</code></td><td class="c-table__cell u-text">A 1D numpy array representing the span's semantics.</td></tr></table>
Span.vector_norm	 The L2 norm of the span's vector representation.	<p> The L2 norm of the span's vector representation.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">doc = nlp(u'I like apples')<br/>doc[1:].vector_norm # 4.800883928527915<br/>doc[2:].vector_norm # 6.895897646384268<br/>assert doc[1:].vector_norm != doc[2:].vector_norm<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">float</td><td class="c-table__cell u-text">The L2 norm of the vector representation.</td></tr></table>
Attributes		<table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>doc</code></td><td class="c-table__cell u-text"><code>Doc</code></td><td class="c-table__cell u-text">The parent document.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>sent</code></td><td class="c-table__cell u-text"><code>Span</code></td><td class="c-table__cell u-text">The sentence span that this span is a part of.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>start</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">The token offset for the start of the span.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>end</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">The token offset for the end of the span.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>start_char</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">The character offset for the start of the span.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>end_char</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">The character offset for the end of the span.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>text</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">A unicode representation of the span text.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>text_with_ws</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text"> The text content of the span with a trailing whitespace characterif the last token has one.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>orth</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">ID of the verbatim text content.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>orth_</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text"> Verbatim text content (identical to <code>Span.text</code>). Exists mostly for consistency with the other attributes.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>label</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">The span's label.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>label_</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">The span's label.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>lemma_</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">The span's lemma.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>ent_id</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">The hash value of the named entity the token is an instance of.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>ent_id_</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">The string ID of the named entity the token is an instance of.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>sentiment</code></td><td class="c-table__cell u-text">float</td><td class="c-table__cell u-text"> A scalar value indicating the positivity or negativity of thespan.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>_</code></td><td class="c-table__cell u-text"><code>Underscore</code></td><td class="c-table__cell u-text"> User space for adding custom <a href="../usage/processing-pipelines#custom-components-attributes">attribute extensions</a>.</td></tr></table>
DependencyParser.Model	 Initialise a model for the pipe. The model should implement the thinc.neural.Model API. Wrappers are under development for most major machine learning libraries.	<p> Initialise a model for the pipe. The model should implement the <code>thinc.neural.Model</code> API. Wrappers are under development for most major machine learning libraries.</p><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>**kwargs</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text">Parameters for initialising the model</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">object</td><td class="c-table__cell u-text">The initialised model.</td></tr></table>
DependencyParser.__init__	Create a new pipeline instance.	<p>Create a new pipeline instance.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">from spacy.pipeline import DependencyParser<br/>parser = DependencyParser(nlp.vocab)<br/>parser.from_disk('/path/to/model')<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>vocab</code></td><td class="c-table__cell u-text"><code>Vocab</code></td><td class="c-table__cell u-text">The shared vocabulary.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>model</code></td><td class="c-table__cell u-text"><code>thinc.neural.Model</code> or <code>True</code></td><td class="c-table__cell u-text"> The model powering the pipeline component. If no model issupplied, the model is created when you call <code>begin_training</code>, <code>from_disk</code> or <code>from_bytes</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>**cfg</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text">Configuration parameters.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code>DependencyParser</code></td><td class="c-table__cell u-text">The newly constructed object.</td></tr></table>
DependencyParser.__call__	 Apply the pipe to one document. The document is modified in place, and returned. Both DependencyParser.__call__ and DependencyParser.pipe should delegate to the DependencyParser.predict and DependencyParser.set_annotations methods.	<p> Apply the pipe to one document. The document is modified in place, and returned. Both <code>DependencyParser.__call__</code> and <code>DependencyParser.pipe</code> should delegate to the <code>DependencyParser.predict</code> and <code>DependencyParser.set_annotations</code> methods.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">parser = DependencyParser(nlp.vocab)<br/>doc = nlp(u"This is a sentence.")<br/>processed = parser(doc)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>doc</code></td><td class="c-table__cell u-text"><code>Doc</code></td><td class="c-table__cell u-text">The document to process.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code>Doc</code></td><td class="c-table__cell u-text">The processed document.</td></tr></table>
DependencyParser.pipe	 Apply the pipe to a stream of documents. Both DependencyParser.__call__ and DependencyParser.pipe should delegate to the DependencyParser.predict and DependencyParser.set_annotations methods.	<p> Apply the pipe to a stream of documents. Both <code>DependencyParser.__call__</code> and <code>DependencyParser.pipe</code> should delegate to the <code>DependencyParser.predict</code> and <code>DependencyParser.set_annotations</code> methods.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">texts = [u'One doc', u'...', u'Lots of docs']<br/>parser = DependencyParser(nlp.vocab)<br/>for doc in parser.pipe(texts, batch_size=50):<br/>    pass<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>stream</code></td><td class="c-table__cell u-text">iterable</td><td class="c-table__cell u-text">A stream of documents.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>batch_size</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">The number of texts to buffer. Defaults to <code>128</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>n_threads</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text"> The number of worker threads to use. If <code>-1</code>, OpenMP will decide how many to use at run time. Default is <code>-1</code>.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">yields</td><td class="c-table__cell u-text"><code>Doc</code></td><td class="c-table__cell u-text">Processed documents in the order of the original text.</td></tr></table>
DependencyParser.predict	 Apply the pipeline's model to a batch of docs, without modifying them.	<p> Apply the pipeline's model to a batch of docs, without modifying them.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">parser = DependencyParser(nlp.vocab)<br/>scores = parser.predict([doc1, doc2])<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>docs</code></td><td class="c-table__cell u-text">iterable</td><td class="c-table__cell u-text">The documents to predict.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text">Scores from the model.</td></tr></table>
DependencyParser.set_annotations	 Modify a batch of documents, using pre-computed scores.	<p> Modify a batch of documents, using pre-computed scores.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">parser = DependencyParser(nlp.vocab)<br/>scores = parser.predict([doc1, doc2])<br/>parser.set_annotations([doc1, doc2], scores)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>docs</code></td><td class="c-table__cell u-text">iterable</td><td class="c-table__cell u-text">The documents to modify.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>scores</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text">The scores to set, produced by <code>DependencyParser.predict</code>.</td></tr></table>
DependencyParser.update	 Learn from a batch of documents and gold-standard information, updating the pipe's model. Delegates to DependencyParser.predict and DependencyParser.get_loss.	<p> Learn from a batch of documents and gold-standard information, updating the pipe's model. Delegates to <code>DependencyParser.predict</code> and <code>DependencyParser.get_loss</code>.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">parser = DependencyParser(nlp.vocab)<br/>losses = {}<br/>optimizer = nlp.begin_training()<br/>parser.update([doc1, doc2], [gold1, gold2], losses=losses, sgd=optimizer)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>docs</code></td><td class="c-table__cell u-text">iterable</td><td class="c-table__cell u-text">A batch of documents to learn from.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>golds</code></td><td class="c-table__cell u-text">iterable</td><td class="c-table__cell u-text">The gold-standard data. Must have the same length as <code>docs</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>drop</code></td><td class="c-table__cell u-text">float</td><td class="c-table__cell u-text">The dropout rate.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>sgd</code></td><td class="c-table__cell u-text">callable</td><td class="c-table__cell u-text"> The optimizer. Should take two arguments <code>weights</code> and <code>gradient</code>, and an optional ID.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>losses</code></td><td class="c-table__cell u-text">dict</td><td class="c-table__cell u-text"> Optional record of the loss during training. The value keyed bythe model's name is updated.</td></tr></table>
DependencyParser.get_loss	 Find the loss and gradient of loss for the batch of documents and their
predicted scores.	<p> Find the loss and gradient of loss for the batch of documents and theirpredicted scores.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">parser = DependencyParser(nlp.vocab)<br/>scores = parser.predict([doc1, doc2])<br/>loss, d_loss = parser.get_loss([doc1, doc2], [gold1, gold2], scores)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>docs</code></td><td class="c-table__cell u-text">iterable</td><td class="c-table__cell u-text">The batch of documents.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>golds</code></td><td class="c-table__cell u-text">iterable</td><td class="c-table__cell u-text">The gold-standard data. Must have the same length as <code>docs</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>scores</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text">Scores representing the model's predictions.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">tuple</td><td class="c-table__cell u-text">The loss and the gradient, i.e. <code>(loss, gradient)</code>.</td></tr></table>
DependencyParser.begin_training	 Initialise the pipe for training, using data exampes if available. If no
model has been initialised yet, the model is added.	<p> Initialise the pipe for training, using data exampes if available. If nomodel has been initialised yet, the model is added.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">parser = DependencyParser(nlp.vocab)<br/>nlp.pipeline.append(parser)<br/>optimizer = parser.begin_training(pipeline=nlp.pipeline)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>gold_tuples</code></td><td class="c-table__cell u-text">iterable</td><td class="c-table__cell u-text"> Optional gold-standard annotations from which to construct <a class="u-no-border u-inline-block u-nowrap" href="goldparse" target="_self"><code>GoldParse</code> <svg aria-hidden="true" class="o-icon o-icon--inline u-color-theme" height="16" style="min-width: 16px" viewbox="0 0 16 16" width="16"><use xlink:href="#svg_book"></use></svg></a> objects.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>pipeline</code></td><td class="c-table__cell u-text">list</td><td class="c-table__cell u-text"> Optional list of <a class="u-no-border u-inline-block u-nowrap" href="pipe" target="_self"><code>Pipe</code> <svg aria-hidden="true" class="o-icon o-icon--inline u-color-theme" height="16" style="min-width: 16px" viewbox="0 0 16 16" width="16"><use xlink:href="#svg_book"></use></svg></a> components that this component is part of.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>sgd</code></td><td class="c-table__cell u-text">callable</td><td class="c-table__cell u-text"> An optional optimizer. Should take two arguments <code>weights</code> and <code>gradient</code>, and an optional ID. Will be created via <a class="u-no-border u-inline-block u-nowrap" href="dependencyparser#create_optimizer" target="_self"><code>create_optimizer</code> <svg aria-hidden="true" class="o-icon o-icon--inline u-color-theme" height="16" style="min-width: 16px" viewbox="0 0 16 16" width="16"><use xlink:href="#svg_book"></use></svg></a> if not set.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">callable</td><td class="c-table__cell u-text">An optimizer.</td></tr></table>
DependencyParser.create_optimizer	 Create an optmizer for the pipeline component.	<p> Create an optmizer for the pipeline component.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">parser = DependencyParser(nlp.vocab)<br/>optimizer = parser.create_optimizer()<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">callable</td><td class="c-table__cell u-text">The optimizer.</td></tr></table>
DependencyParser.use_params	Modify the pipe's model, to use the given parameter values.	<p>Modify the pipe's model, to use the given parameter values.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">parser = DependencyParser(nlp.vocab)<br/>with parser.use_params():<br/>    parser.to_disk('/best_model')<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>params</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text"> The parameter values to use in the model. At the end of thecontext, the original parameters are restored.</td></tr></table>
DependencyParser.add_label	Add a new label to the pipe.	<p>Add a new label to the pipe.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">parser = DependencyParser(nlp.vocab)<br/>parser.add_label('MY_LABEL')<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>label</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">The label to add.</td></tr></table>
DependencyParser.to_disk	Serialize the pipe to disk.	<p>Serialize the pipe to disk.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">parser = DependencyParser(nlp.vocab)<br/>parser.to_disk('/path/to/parser')<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>path</code></td><td class="c-table__cell u-text">unicode or <code>Path</code></td><td class="c-table__cell u-text"> A path to a directory, which will be created if it doesn't exist. Paths may be either strings or <code>Path</code>-like objects.</td></tr></table>
DependencyParser.from_disk	Load the pipe from disk. Modifies the object in place and returns it.	<p>Load the pipe from disk. Modifies the object in place and returns it.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">parser = DependencyParser(nlp.vocab)<br/>parser.from_disk('/path/to/parser')<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>path</code></td><td class="c-table__cell u-text">unicode or <code>Path</code></td><td class="c-table__cell u-text"> A path to a directory. Paths may be either strings or <code>Path</code>-like objects.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code>DependencyParser</code></td><td class="c-table__cell u-text">The modified <code>DependencyParser</code> object.</td></tr></table>
DependencyParser.to_bytes		<aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">parser = DependencyParser(nlp.vocab)<br/>parser_bytes = parser.to_bytes()<br/></code></pre></div></aside><p>Serialize the pipe to a bytestring.</p><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>**exclude</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text">Named attributes to prevent from being serialized.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">bytes</td><td class="c-table__cell u-text">The serialized form of the <code>DependencyParser</code> object.</td></tr></table>
DependencyParser.from_bytes	Load the pipe from a bytestring. Modifies the object in place and returns it.	<p>Load the pipe from a bytestring. Modifies the object in place and returns it.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">parser_bytes = parser.to_bytes()<br/>parser = DependencyParser(nlp.vocab)<br/>parser.from_bytes(parser_bytes)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>bytes_data</code></td><td class="c-table__cell u-text">bytes</td><td class="c-table__cell u-text">The data to load from.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>**exclude</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text">Named attributes to prevent from being loaded.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code>DependencyParser</code></td><td class="c-table__cell u-text">The <code>DependencyParser</code> object.</td></tr></table>
PhraseMatcher.__init__	Create the rule-based PhraseMatcher.	<p>Create the rule-based <code>PhraseMatcher</code>.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">from spacy.matcher import PhraseMatcher<br/>matcher = PhraseMatcher(nlp.vocab, max_length=6)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>vocab</code></td><td class="c-table__cell u-text"><code>Vocab</code></td><td class="c-table__cell u-text"> The vocabulary object, which must be shared with the documentsthe matcher will operate on.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>max_length</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">Maximum length of a phrase pattern to add.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code>PhraseMatcher</code></td><td class="c-table__cell u-text">The newly constructed object.</td></tr></table>
PhraseMatcher.__call__	Find all token sequences matching the supplied patterns on the Doc.	<p>Find all token sequences matching the supplied patterns on the <code>Doc</code>.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">from spacy.matcher import PhraseMatcher<br/><br/>matcher = PhraseMatcher(nlp.vocab)<br/>matcher.add('OBAMA', None, nlp(u"Barack Obama"))<br/>doc = nlp(u"Barack Obama lifts America one last time in emotional farewell")<br/>matches = matcher(doc)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>doc</code></td><td class="c-table__cell u-text"><code>Doc</code></td><td class="c-table__cell u-text">The document to match over.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">list</td><td class="c-table__cell u-text"> A list of <code>(match_id, start, end)</code> tuples, describing the matches. A match tuple describes a span <code>doc[start:end]</code>. The <code>match_id</code> is the ID of the added match pattern.</td></tr></table>
PhraseMatcher.pipe	Match a stream of documents, yielding them in turn.	<p>Match a stream of documents, yielding them in turn.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">from spacy.matcher import PhraseMatcher<br/>matcher = PhraseMatcher(nlp.vocab)<br/>for doc in matcher.pipe(texts, batch_size=50, n_threads=4):<br/>    pass<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>docs</code></td><td class="c-table__cell u-text">iterable</td><td class="c-table__cell u-text">A stream of documents.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>batch_size</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">The number of documents to accumulate into a working set.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>n_threads</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text"> The number of threads with which to work on the buffer in parallel, if the <code>PhraseMatcher</code> implementation supports multi-threading.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">yields</td><td class="c-table__cell u-text"><code>Doc</code></td><td class="c-table__cell u-text">Documents, in order.</td></tr></table>
PhraseMatcher.__len__	 Get the number of rules added to the matcher. Note that this only returns
the number of rules (identical with the number of IDs), not the number
of individual patterns.	<p> Get the number of rules added to the matcher. Note that this only returnsthe number of rules (identical with the number of IDs), not the numberof individual patterns.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">matcher = PhraseMatcher(nlp.vocab)<br/>assert len(matcher) == 0<br/>matcher.add('OBAMA', None, nlp(u"Barack Obama"))<br/>assert len(matcher) == 1<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">The number of rules.</td></tr></table>
PhraseMatcher.__contains__	Check whether the matcher contains rules for a match ID.	<p>Check whether the matcher contains rules for a match ID.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">matcher = PhraseMatcher(nlp.vocab)<br/>assert 'OBAMA' not in matcher<br/>matcher.add('OBAMA', None, nlp(u"Barack Obama"))<br/>assert 'OBAMA' in matcher<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>key</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">The match ID.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">Whether the matcher contains rules for this match ID.</td></tr></table>
PhraseMatcher.add	 Add a rule to the matcher, consisting of an ID key, one or more patterns, and
a callback function to act on the matches. The callback function will receive the arguments matcher, doc, i and matches. If a pattern already exists for the given ID, the patterns will be extended. An on_match callback will be overwritten.	<p> Add a rule to the matcher, consisting of an ID key, one or more patterns, anda callback function to act on the matches. The callback function will receive the arguments <code>matcher</code>, <code>doc</code>, <code>i</code> and <code>matches</code>. If a pattern already exists for the given ID, the patterns will be extended. An <code>on_match</code> callback will be overwritten.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">def on_match(matcher, doc, id, matches):<br/>    print('Matched!', matches)<br/><br/>matcher = PhraseMatcher(nlp.vocab)<br/>matcher.add('OBAMA', on_match, nlp(u"Barack Obama"))<br/>matcher.add('HEALTH', on_match, nlp(u"health care reform"),<br/>                                nlp(u"healthcare reform"))<br/>doc = nlp(u"Barack Obama urges Congress to find courage to defend his healthcare reforms")<br/>matches = matcher(doc)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>match_id</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">An ID for the thing you're matching.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>on_match</code></td><td class="c-table__cell u-text">callable or <code>None</code></td><td class="c-table__cell u-text"> Callback function to act on matches. Takes the arguments <code>matcher</code>, <code>doc</code>, <code>i</code> and <code>matches</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>*docs</code></td><td class="c-table__cell u-text">list</td><td class="c-table__cell u-text"> <code>Doc</code> objects of the phrases to match.</td></tr></table>
Doc.__init__	 Construct a Doc object. The most common way to get a Doc object is via the nlp object.	<p> Construct a <code>Doc</code> object. The most common way to get a <code>Doc</code> object is via the <code>nlp</code> object.</p><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>vocab</code></td><td class="c-table__cell u-text"><code>Vocab</code></td><td class="c-table__cell u-text">A storage container for lexical types.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>words</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text">A list of strings to add to the container.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>spaces</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text"> A list of boolean values indicating whether each word has a subsequent space. Must have the same length as <code>words</code>, if specified. Defaults to a sequence of <code>True</code>.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code>Doc</code></td><td class="c-table__cell u-text">The newly constructed object.</td></tr></table>
Doc.__getitem__	 Get a Token  object at position i, where i is an integer. Negative indexing is supported, and follows the usual Python semantics, i.e. doc[-2] is doc[len(doc) - 2].	<p> Get a <a class="u-no-border u-inline-block u-nowrap" href="token" target="_self"><code>Token</code> <svg aria-hidden="true" class="o-icon o-icon--inline u-color-theme" height="16" style="min-width: 16px" viewbox="0 0 16 16" width="16"><use xlink:href="#svg_book"></use></svg></a> object at position <code>i</code>, where <code>i</code> is an integer. Negative indexing is supported, and follows the usual Python semantics, i.e. <code>doc[-2]</code> is <code>doc[len(doc) - 2]</code>.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">doc = nlp(u'Give it back! He pleaded.')<br/>assert doc[0].text == 'Give'<br/>assert doc[-1].text == '.'<br/>span = doc[1:3]<br/>assert span.text == 'it back'<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>i</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">The index of the token.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code>Token</code></td><td class="c-table__cell u-text">The token at <code>doc[i]</code>.</td></tr></table><p> Get a <a class="u-no-border u-inline-block u-nowrap" href="span" target="_self"><code>Span</code> <svg aria-hidden="true" class="o-icon o-icon--inline u-color-theme" height="16" style="min-width: 16px" viewbox="0 0 16 16" width="16"><use xlink:href="#svg_book"></use></svg></a> object, starting at position <code>start</code> (token index) and ending at position <code>end</code> (token index).</p><p> For instance, <code>doc[2:5]</code> produces a span consisting of tokens 2, 3 and 4. Stepped slices (e.g. <code>doc[start : end : step]</code>) are not supported, as <code>Span</code> objects must be contiguous (cannot have gaps). You can use negative indices and open-ended ranges, which have theirnormal Python semantics.</p><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>start_end</code></td><td class="c-table__cell u-text">tuple</td><td class="c-table__cell u-text">The slice of the document to get.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code>Span</code></td><td class="c-table__cell u-text">The span at <code>doc[start : end]</code>.</td></tr></table>
Doc.__iter__	 Iterate over Token objects, from which the annotations can be easily accessed.	<p> Iterate over <code>Token</code> objects, from which the annotations can be easily accessed.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">doc = nlp(u'Give it back')<br/>assert [t.text for t in doc] == [u'Give', u'it', u'back']<br/></code></pre></div></aside><p> This is the main way of accessing <a class="u-no-border u-inline-block u-nowrap" href="token" target="_self"><code>Token</code> <svg aria-hidden="true" class="o-icon o-icon--inline u-color-theme" height="16" style="min-width: 16px" viewbox="0 0 16 16" width="16"><use xlink:href="#svg_book"></use></svg></a> objects, which are the main way annotations are accessed from Python. Iffaster-than-Python speeds are required, you can instead access theannotations as a numpy array, or access the underlying C data directlyfrom Cython.</p><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">yields</td><td class="c-table__cell u-text"><code>Token</code></td><td class="c-table__cell u-text">A <code>Token</code> object.</td></tr></table>
Doc.__len__	Get the number of tokens in the document.	<p>Get the number of tokens in the document.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">doc = nlp(u'Give it back! He pleaded.')<br/>assert len(doc) == 7<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">The number of tokens in the document.</td></tr></table>
Doc.set_extension	 Define a custom attribute on the Doc which becomes available via Doc._. For details, see the documentation on custom attributes.	<p> Define a custom attribute on the <code>Doc</code> which becomes available via <code>Doc._</code>. For details, see the documentation on <a href="../usage/processing-pipelines#custom-components-attributes">custom attributes</a>.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">from spacy.tokens import Doc<br/>city_getter = lambda doc: any(city in doc.text for city in ('New York', 'Paris', 'Berlin'))<br/>Doc.set_extension('has_city', getter=city_getter)<br/>doc = nlp(u'I like New York')<br/>assert doc._.has_city<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>name</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text"> Name of the attribute to set by the extension. For example, <code>'my_attr'</code> will be available as <code>doc._.my_attr</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>default</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text"> Optional default value of the attribute if no getter or methodis defined.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>method</code></td><td class="c-table__cell u-text">callable</td><td class="c-table__cell u-text"> Set a custom method on the object, for example <code>doc._.compare(other_doc)</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>getter</code></td><td class="c-table__cell u-text">callable</td><td class="c-table__cell u-text"> Getter function that takes the object and returns an attribute value. Is called when the user accesses the <code>._</code> attribute.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>setter</code></td><td class="c-table__cell u-text">callable</td><td class="c-table__cell u-text"> Setter function that takes the <code>Doc</code> and a value, and modifies the object. Is called when the user writes to the <code>Doc._</code> attribute.</td></tr></table>
Doc.get_extension	 Look up a previously registered extension by name. Returns a 4-tuple (default, method, getter, setter) if the extension is registered. Raises a KeyError otherwise.	<p> Look up a previously registered extension by name. Returns a 4-tuple <code class="u-break">(default, method, getter, setter)</code> if the extension is registered. Raises a <code>KeyError</code> otherwise.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">from spacy.tokens import Doc<br/>Doc.set_extension('is_city', default=False)<br/>extension = Doc.get_extension('is_city')<br/>assert extension == (False, None, None, None)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>name</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">Name of the extension.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">tuple</td><td class="c-table__cell u-text"> A <code class="u-break">(default, method, getter, setter)</code> tuple of the extension.</td></tr></table>
Doc.has_extension	Check whether an extension has been registered on the Doc class.	<p>Check whether an extension has been registered on the <code>Doc</code> class.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">from spacy.tokens import Doc<br/>Doc.set_extension('is_city', default=False)<br/>assert Doc.has_extension('is_city')<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>name</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">Name of the extension to check.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text">Whether the extension has been registered.</td></tr></table>
Doc.char_span	 Create a Span object from the slice doc.text[start : end]. Returns None if the character indices don't map to a valid span.	<p> Create a <code>Span</code> object from the slice <code>doc.text[start : end]</code>. Returns <code>None</code> if the character indices don't map to a valid span.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">doc = nlp(u'I like New York')<br/>span = doc.char_span(7, 15, label=u'GPE')<br/>assert span.text == 'New York'<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>start</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">The index of the first character of the span.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>end</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">The index of the first character after the span.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>label</code></td><td class="c-table__cell u-text">uint64 / unicode</td><td class="c-table__cell u-text">A label to attach to the Span, e.g. for named entities.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>vector</code></td><td class="c-table__cell u-text"><code class="u-break">numpy.ndarray[ndim=1, dtype='float32']</code></td><td class="c-table__cell u-text">A meaning representation of the span.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code>Span</code></td><td class="c-table__cell u-text">The newly constructed object or <code>None</code>.</td></tr></table>
Doc.similarity	 Make a semantic similarity estimate. The default estimate is cosine
similarity using an average of word vectors.	<p> Make a semantic similarity estimate. The default estimate is cosinesimilarity using an average of word vectors.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">apples = nlp(u'I like apples')<br/>oranges = nlp(u'I like oranges')<br/>apples_oranges = apples.similarity(oranges)<br/>oranges_apples = oranges.similarity(apples)<br/>assert apples_oranges == oranges_apples<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>other</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text"> The object to compare with. By default, accepts <code>Doc</code>, <code>Span</code>, <code>Token</code> and <code>Lexeme</code> objects.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">float</td><td class="c-table__cell u-text">A scalar similarity score. Higher is more similar.</td></tr></table>
Doc.count_by	 Count the frequencies of a given attribute. Produces a dict of {attr (int): count (ints)} frequencies, keyed by the values of the given attribute ID.	<p> Count the frequencies of a given attribute. Produces a dict of <code>{attr (int): count (ints)}</code> frequencies, keyed by the values of the given attribute ID.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">from spacy.attrs import ORTH<br/>doc = nlp(u'apple apple orange banana')<br/>assert doc.count_by(ORTH) == {7024L: 1, 119552L: 1, 2087L: 2}<br/>doc.to_array([attrs.ORTH])<br/># array([[11880], [11880], [7561], [12800]])<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>attr_id</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">The attribute ID</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">dict</td><td class="c-table__cell u-text">A dictionary mapping attributes to integer counts.</td></tr></table>
Doc.get_lca_matrix	 Calculates the lowest common ancestor matrix for a given Doc. Returns LCA matrix containing the integer index of the ancestor, or -1 if no common ancestor is found, e.g. if span excludes a necessary ancestor.	<p> Calculates the lowest common ancestor matrix for a given <code>Doc</code>. Returns LCA matrix containing the integer index of the ancestor, or <code>-1</code> if no common ancestor is found, e.g. if span excludes a necessary ancestor.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">doc = nlp(u"This is a test")<br/>matrix = doc.get_lca_matrix()<br/># array([[0, 1, 1, 1], [1, 1, 1, 1], [1, 1, 2, 3], [1, 1, 3, 3]], dtype=int32)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code class="u-break">numpy.ndarray[ndim=2, dtype='int32']</code></td><td class="c-table__cell u-text">The lowest common ancestor matrix of the <code>Doc</code>.</td></tr></table>
Doc.to_array	 Export given token attributes to a numpy ndarray. If attr_ids is a sequence of M attributes, the output array will be of shape (N, M), where N is the length of the Doc (in tokens). If attr_ids is a single attribute, the output shape will be (N,). You can specify attributes by integer ID (e.g. spacy.attrs.LEMMA) or string name (e.g. 'LEMMA' or 'lemma'). The values will be 64-bit
integers.	<p> Export given token attributes to a numpy <code>ndarray</code>. If <code>attr_ids</code> is a sequence of <code>M</code> attributes, the output array will be of shape <code>(N, M)</code>, where <code>N</code> is the length of the <code>Doc</code> (in tokens). If <code>attr_ids</code> is a single attribute, the output shape will be <code>(N,)</code>. You can specify attributes by integer ID (e.g. <code>spacy.attrs.LEMMA</code>) or string name (e.g. 'LEMMA' or 'lemma'). The values will be 64-bitintegers.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">from spacy.attrs import LOWER, POS, ENT_TYPE, IS_ALPHA<br/>doc = nlp(text)<br/># All strings mapped to integers, for easy export to numpy<br/>np_array = doc.to_array([LOWER, POS, ENT_TYPE, IS_ALPHA])<br/>np_array = doc.to_array("POS")<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>attr_ids</code></td><td class="c-table__cell u-text">list or int or string</td><td class="c-table__cell u-text">A list of attributes (int IDs or string names) ora single attribute (int ID or string name)</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code class="u-break">numpy.ndarray[ndim=2, dtype='uint64']</code> or<code class="u-break">numpy.ndarray[ndim=1, dtype='uint64']</code> or</td><td class="c-table__cell u-text"> The exported attributes as a 2D numpy array, with one row per token and one column per attribute (when <code>attr_ids</code> is a list), or as a 1D numpy array, with one item per attribute (when <code>attr_ids</code> is a single value).</td></tr></table>
Doc.from_array	 Load attributes from a numpy array. Write to a Doc object, from an (M, N) array of attributes.	<p> Load attributes from a numpy array. Write to a <code>Doc</code> object, from an <code>(M, N)</code> array of attributes.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">from spacy.attrs import LOWER, POS, ENT_TYPE, IS_ALPHA<br/>from spacy.tokens import Doc<br/>doc = nlp("Hello world!")<br/>np_array = doc.to_array([LOWER, POS, ENT_TYPE, IS_ALPHA])<br/>doc2 = Doc(doc.vocab, words=[t.text for t in doc])<br/>doc2.from_array([LOWER, POS, ENT_TYPE, IS_ALPHA], np_array)<br/>assert doc[0].pos_ == doc2[0].pos_<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>attrs</code></td><td class="c-table__cell u-text">ints</td><td class="c-table__cell u-text">A list of attribute ID ints.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>array</code></td><td class="c-table__cell u-text"><code class="u-break">numpy.ndarray[ndim=2, dtype='int32']</code></td><td class="c-table__cell u-text">The attribute values to load.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code>Doc</code></td><td class="c-table__cell u-text">Itself.</td></tr></table>
Doc.to_disk	Save the current state to a directory.	<p>Save the current state to a directory.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">doc.to_disk('/path/to/doc')<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>path</code></td><td class="c-table__cell u-text">unicode or <code>Path</code></td><td class="c-table__cell u-text"> A path to a directory, which will be created if it doesn't exist. Paths may be either strings or <code>Path</code>-like objects.</td></tr></table>
Doc.from_disk	Loads state from a directory. Modifies the object in place and returns it.	<p>Loads state from a directory. Modifies the object in place and returns it.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">from spacy.tokens import Doc<br/>from spacy.vocab import Vocab<br/>doc = Doc(Vocab()).from_disk('/path/to/doc')<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>path</code></td><td class="c-table__cell u-text">unicode or <code>Path</code></td><td class="c-table__cell u-text"> A path to a directory. Paths may be either strings or <code>Path</code>-like objects.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code>Doc</code></td><td class="c-table__cell u-text">The modified <code>Doc</code> object.</td></tr></table>
Doc.to_bytes	Serialize, i.e. export the document contents to a binary string.	<p>Serialize, i.e. export the document contents to a binary string.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">doc = nlp(u'Give it back! He pleaded.')<br/>doc_bytes = doc.to_bytes()<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">bytes</td><td class="c-table__cell u-text"> A losslessly serialized copy of the <code>Doc</code>, including all annotations.</td></tr></table>
Doc.from_bytes	Deserialize, i.e. import the document contents from a binary string.	<p>Deserialize, i.e. import the document contents from a binary string.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">from spacy.tokens import Doc<br/>text = u'Give it back! He pleaded.'<br/>doc = nlp(text)<br/>bytes = doc.to_bytes()<br/>doc2 = Doc(doc.vocab).from_bytes(bytes)<br/>assert doc.text == doc2.text<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>data</code></td><td class="c-table__cell u-text">bytes</td><td class="c-table__cell u-text">The string to load from.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code>Doc</code></td><td class="c-table__cell u-text">The <code>Doc</code> object.</td></tr></table>
Doc.merge	 Retokenize the document, such that the span at doc.text[start_idx : end_idx] is merged into a single token. If start_idx and end_idx do not mark start and end token boundaries, the document remains unchanged.	<p> Retokenize the document, such that the span at <code>doc.text[start_idx : end_idx]</code> is merged into a single token. If <code>start_idx</code> and <code>end_idx</code> do not mark start and end token boundaries, the document remains unchanged.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">doc = nlp(u'Los Angeles start.')<br/>doc.merge(0, len('Los Angeles'), 'NNP', 'Los Angeles', 'GPE')<br/>assert [t.text for t in doc] == [u'Los Angeles', u'start', u'.']<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>start_idx</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">The character index of the start of the slice to merge.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>end_idx</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">The character index after the end of the slice to merge.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>**attributes</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text"> Attributes to assign to the merged token. By default,attributes are inherited from the syntactic root token ofthe span.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code>Token</code></td><td class="c-table__cell u-text"> The newly merged token, or <code>None</code> if the start and end indices did not fall at token boundaries</td></tr></table>
Doc.print_tree	 Returns the parse trees in JSON (dict) format. Especially useful for
web applications.	<p> Returns the parse trees in JSON (dict) format. Especially useful forweb applications.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">doc = nlp('Alice ate the pizza.')<br/>trees = doc.print_tree()<br/># {'modifiers': [<br/>#   {'modifiers': [], 'NE': 'PERSON', 'word': 'Alice', 'arc': 'nsubj', 'POS_coarse': 'PROPN', 'POS_fine': 'NNP', 'lemma': 'Alice'},<br/>#   {'modifiers': [{'modifiers': [], 'NE': '', 'word': 'the', 'arc': 'det', 'POS_coarse': 'DET', 'POS_fine': 'DT', 'lemma': 'the'}], 'NE': '', 'word': 'pizza', 'arc': 'dobj', 'POS_coarse': 'NOUN', 'POS_fine': 'NN', 'lemma': 'pizza'},<br/>#   {'modifiers': [], 'NE': '', 'word': '.', 'arc': 'punct', 'POS_coarse': 'PUNCT', 'POS_fine': '.', 'lemma': '.'}<br/># ], 'NE': '', 'word': 'ate', 'arc': 'ROOT', 'POS_coarse': 'VERB', 'POS_fine': 'VBD', 'lemma': 'eat'}<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>light</code></td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text">Don't include lemmas or entities.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>flat</code></td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text">Don't include arcs or modifiers.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">dict</td><td class="c-table__cell u-text">Parse tree as dict.</td></tr></table>
Doc.ents	 Iterate over the entities in the document. Yields named-entity Span objects, if the entity recognizer has been applied to the document.	<p> Iterate over the entities in the document. Yields named-entity <code>Span</code> objects, if the entity recognizer has been applied to the document.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">tokens = nlp(u'Mr. Best flew to New York on Saturday morning.')<br/>ents = list(tokens.ents)<br/>assert ents[0].label == 346<br/>assert ents[0].label_ == 'PERSON'<br/>assert ents[0].text == 'Mr. Best'<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">yields</td><td class="c-table__cell u-text"><code>Span</code></td><td class="c-table__cell u-text">Entities in the document.</td></tr></table>
Doc.noun_chunks	 Iterate over the base noun phrases in the document. Yields base noun-phrase Span objects, if the document has been syntactically parsed. A base noun phrase, or "NP chunk", is a noun phrase that does not
permit other NPs to be nested within it – so no NP-level coordination, no
prepositional phrases, and no relative clauses.	<p> Iterate over the base noun phrases in the document. Yields base noun-phrase <code>Span</code> objects, if the document has been syntactically parsed. A base noun phrase, or "NP chunk", is a noun phrase that does notpermit other NPs to be nested within it – so no NP-level coordination, noprepositional phrases, and no relative clauses.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">doc = nlp(u'A phrase with another phrase occurs.')<br/>chunks = list(doc.noun_chunks)<br/>assert chunks[0].text == "A phrase"<br/>assert chunks[1].text == "another phrase"<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">yields</td><td class="c-table__cell u-text"><code>Span</code></td><td class="c-table__cell u-text">Noun chunks in the document.</td></tr></table>
Doc.sents	 Iterate over the sentences in the document. Sentence spans have no label.
To improve accuracy on informal texts, spaCy calculates sentence boundaries
from the syntactic dependency parse. If the parser is disabled, the sents iterator will be unavailable.	<p> Iterate over the sentences in the document. Sentence spans have no label.To improve accuracy on informal texts, spaCy calculates sentence boundariesfrom the syntactic dependency parse. If the parser is disabled, the <code>sents</code> iterator will be unavailable.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">doc = nlp(u"This is a sentence. Here's another...")<br/>sents = list(doc.sents)<br/>assert len(sents) == 2<br/>assert [s.root.text for s in sents] == ["is", "'s"]<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">yields</td><td class="c-table__cell u-text"><code>Span</code></td><td class="c-table__cell u-text">Sentences in the document.</td></tr></table>
Doc.has_vector	 A boolean value indicating whether a word vector is associated with the
object.	<p> A boolean value indicating whether a word vector is associated with theobject.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">doc = nlp(u'I like apples')<br/>assert doc.has_vector<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text">Whether the document has a vector data attached.</td></tr></table>
Doc.vector	 A real-valued meaning representation. Defaults to an average of the
token vectors.	<p> A real-valued meaning representation. Defaults to an average of thetoken vectors.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">doc = nlp(u'I like apples')<br/>assert doc.vector.dtype == 'float32'<br/>assert doc.vector.shape == (300,)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code class="u-break">numpy.ndarray[ndim=1, dtype='float32']</code></td><td class="c-table__cell u-text">A 1D numpy array representing the document's semantics.</td></tr></table>
Doc.vector_norm	 The L2 norm of the document's vector representation.	<p> The L2 norm of the document's vector representation.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">doc1 = nlp(u'I like apples')<br/>doc2 = nlp(u'I like oranges')<br/>doc1.vector_norm # 4.54232424414368<br/>doc2.vector_norm # 3.304373298575751<br/>assert doc1.vector_norm != doc2.vector_norm<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">float</td><td class="c-table__cell u-text">The L2 norm of the vector representation.</td></tr></table>
Attributes		<table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>text</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">A unicode representation of the document text.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>text_with_ws</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text"> An alias of <code>Doc.text</code>, provided for duck-type compatibility with <code>Span</code> and <code>Token</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>mem</code></td><td class="c-table__cell u-text"><code>Pool</code></td><td class="c-table__cell u-text">The document's local memory heap, for all C data it owns.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>vocab</code></td><td class="c-table__cell u-text"><code>Vocab</code></td><td class="c-table__cell u-text">The store of lexical types.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>tensor</code> <div class="u-text-tag u-text-tag--spaced" data-tooltip="This feature is new and was introduced in spaCy v2.0">v2.0 <span aria-role="tooltip" class="u-hidden">This feature is new and was introduced in spaCy v2.0</span></div></td><td class="c-table__cell u-text">object</td><td class="c-table__cell u-text">Container for dense vector representations.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>cats</code> <div class="u-text-tag u-text-tag--spaced" data-tooltip="This feature is new and was introduced in spaCy v2.0">v2.0 <span aria-role="tooltip" class="u-hidden">This feature is new and was introduced in spaCy v2.0</span></div></td><td class="c-table__cell u-text">dictionary</td><td class="c-table__cell u-text"> Maps either a label to a score for categories applied to whole document, or <code>(start_char, end_char, label)</code> to score for categories applied to spans. <code>start_char</code> and <code>end_char</code> should be character offsets, label can be either a string or aninteger ID, and score should be a float.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>user_data</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text">A generic storage area, for user custom data.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>is_tagged</code></td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text"> A flag indicating that the document has been part-of-speechtagged.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>is_parsed</code></td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text">A flag indicating that the document has been syntactically parsed.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>sentiment</code></td><td class="c-table__cell u-text">float</td><td class="c-table__cell u-text">The document's positivity/negativity score, if available.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>user_hooks</code></td><td class="c-table__cell u-text">dict</td><td class="c-table__cell u-text"> A dictionary that allows customisation of the <code>Doc</code>'s properties.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>user_token_hooks</code></td><td class="c-table__cell u-text">dict</td><td class="c-table__cell u-text"> A dictionary that allows customisation of properties of <code>Token</code> children.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>user_span_hooks</code></td><td class="c-table__cell u-text">dict</td><td class="c-table__cell u-text"> A dictionary that allows customisation of properties of <code>Span</code> children.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>_</code></td><td class="c-table__cell u-text"><code>Underscore</code></td><td class="c-table__cell u-text"> User space for adding custom <a href="../usage/processing-pipelines#custom-components-attributes">attribute extensions</a>.</td></tr></table>
Tagger.Model	 Initialise a model for the pipe. The model should implement the thinc.neural.Model API. Wrappers are under development for most major machine learning libraries.	<p> Initialise a model for the pipe. The model should implement the <code>thinc.neural.Model</code> API. Wrappers are under development for most major machine learning libraries.</p><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>**kwargs</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text">Parameters for initialising the model</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">object</td><td class="c-table__cell u-text">The initialised model.</td></tr></table>
Tagger.__init__	Create a new pipeline instance.	<p>Create a new pipeline instance.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">from spacy.pipeline import Tagger<br/>tagger = Tagger(nlp.vocab)<br/>tagger.from_disk('/path/to/model')<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>vocab</code></td><td class="c-table__cell u-text"><code>Vocab</code></td><td class="c-table__cell u-text">The shared vocabulary.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>model</code></td><td class="c-table__cell u-text"><code>thinc.neural.Model</code> or <code>True</code></td><td class="c-table__cell u-text"> The model powering the pipeline component. If no model issupplied, the model is created when you call <code>begin_training</code>, <code>from_disk</code> or <code>from_bytes</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>**cfg</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text">Configuration parameters.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code>Tagger</code></td><td class="c-table__cell u-text">The newly constructed object.</td></tr></table>
Tagger.__call__	 Apply the pipe to one document. The document is modified in place, and returned. Both Tagger.__call__ and Tagger.pipe should delegate to the Tagger.predict and Tagger.set_annotations methods.	<p> Apply the pipe to one document. The document is modified in place, and returned. Both <code>Tagger.__call__</code> and <code>Tagger.pipe</code> should delegate to the <code>Tagger.predict</code> and <code>Tagger.set_annotations</code> methods.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">tagger = Tagger(nlp.vocab)<br/>doc = nlp(u"This is a sentence.")<br/>processed = tagger(doc)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>doc</code></td><td class="c-table__cell u-text"><code>Doc</code></td><td class="c-table__cell u-text">The document to process.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code>Doc</code></td><td class="c-table__cell u-text">The processed document.</td></tr></table>
Tagger.pipe	 Apply the pipe to a stream of documents. Both Tagger.__call__ and Tagger.pipe should delegate to the Tagger.predict and Tagger.set_annotations methods.	<p> Apply the pipe to a stream of documents. Both <code>Tagger.__call__</code> and <code>Tagger.pipe</code> should delegate to the <code>Tagger.predict</code> and <code>Tagger.set_annotations</code> methods.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">texts = [u'One doc', u'...', u'Lots of docs']<br/>tagger = Tagger(nlp.vocab)<br/>for doc in tagger.pipe(texts, batch_size=50):<br/>    pass<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>stream</code></td><td class="c-table__cell u-text">iterable</td><td class="c-table__cell u-text">A stream of documents.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>batch_size</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">The number of texts to buffer. Defaults to <code>128</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>n_threads</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text"> The number of worker threads to use. If <code>-1</code>, OpenMP will decide how many to use at run time. Default is <code>-1</code>.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">yields</td><td class="c-table__cell u-text"><code>Doc</code></td><td class="c-table__cell u-text">Processed documents in the order of the original text.</td></tr></table>
Tagger.predict	 Apply the pipeline's model to a batch of docs, without modifying them.	<p> Apply the pipeline's model to a batch of docs, without modifying them.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">tagger = Tagger(nlp.vocab)<br/>scores = tagger.predict([doc1, doc2])<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>docs</code></td><td class="c-table__cell u-text">iterable</td><td class="c-table__cell u-text">The documents to predict.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text">Scores from the model.</td></tr></table>
Tagger.set_annotations	 Modify a batch of documents, using pre-computed scores.	<p> Modify a batch of documents, using pre-computed scores.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">tagger = Tagger(nlp.vocab)<br/>scores = tagger.predict([doc1, doc2])<br/>tagger.set_annotations([doc1, doc2], scores)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>docs</code></td><td class="c-table__cell u-text">iterable</td><td class="c-table__cell u-text">The documents to modify.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>scores</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text">The scores to set, produced by <code>Tagger.predict</code>.</td></tr></table>
Tagger.update	 Learn from a batch of documents and gold-standard information, updating the pipe's model. Delegates to Tagger.predict and Tagger.get_loss.	<p> Learn from a batch of documents and gold-standard information, updating the pipe's model. Delegates to <code>Tagger.predict</code> and <code>Tagger.get_loss</code>.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">tagger = Tagger(nlp.vocab)<br/>losses = {}<br/>optimizer = nlp.begin_training()<br/>tagger.update([doc1, doc2], [gold1, gold2], losses=losses, sgd=optimizer)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>docs</code></td><td class="c-table__cell u-text">iterable</td><td class="c-table__cell u-text">A batch of documents to learn from.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>golds</code></td><td class="c-table__cell u-text">iterable</td><td class="c-table__cell u-text">The gold-standard data. Must have the same length as <code>docs</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>drop</code></td><td class="c-table__cell u-text">float</td><td class="c-table__cell u-text">The dropout rate.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>sgd</code></td><td class="c-table__cell u-text">callable</td><td class="c-table__cell u-text"> The optimizer. Should take two arguments <code>weights</code> and <code>gradient</code>, and an optional ID.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>losses</code></td><td class="c-table__cell u-text">dict</td><td class="c-table__cell u-text"> Optional record of the loss during training. The value keyed bythe model's name is updated.</td></tr></table>
Tagger.get_loss	 Find the loss and gradient of loss for the batch of documents and their
predicted scores.	<p> Find the loss and gradient of loss for the batch of documents and theirpredicted scores.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">tagger = Tagger(nlp.vocab)<br/>scores = tagger.predict([doc1, doc2])<br/>loss, d_loss = tagger.get_loss([doc1, doc2], [gold1, gold2], scores)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>docs</code></td><td class="c-table__cell u-text">iterable</td><td class="c-table__cell u-text">The batch of documents.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>golds</code></td><td class="c-table__cell u-text">iterable</td><td class="c-table__cell u-text">The gold-standard data. Must have the same length as <code>docs</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>scores</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text">Scores representing the model's predictions.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">tuple</td><td class="c-table__cell u-text">The loss and the gradient, i.e. <code>(loss, gradient)</code>.</td></tr></table>
Tagger.begin_training	 Initialise the pipe for training, using data exampes if available. If no
model has been initialised yet, the model is added.	<p> Initialise the pipe for training, using data exampes if available. If nomodel has been initialised yet, the model is added.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">tagger = Tagger(nlp.vocab)<br/>nlp.pipeline.append(tagger)<br/>optimizer = tagger.begin_training(pipeline=nlp.pipeline)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>gold_tuples</code></td><td class="c-table__cell u-text">iterable</td><td class="c-table__cell u-text"> Optional gold-standard annotations from which to construct <a class="u-no-border u-inline-block u-nowrap" href="goldparse" target="_self"><code>GoldParse</code> <svg aria-hidden="true" class="o-icon o-icon--inline u-color-theme" height="16" style="min-width: 16px" viewbox="0 0 16 16" width="16"><use xlink:href="#svg_book"></use></svg></a> objects.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>pipeline</code></td><td class="c-table__cell u-text">list</td><td class="c-table__cell u-text"> Optional list of <a class="u-no-border u-inline-block u-nowrap" href="pipe" target="_self"><code>Pipe</code> <svg aria-hidden="true" class="o-icon o-icon--inline u-color-theme" height="16" style="min-width: 16px" viewbox="0 0 16 16" width="16"><use xlink:href="#svg_book"></use></svg></a> components that this component is part of.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>sgd</code></td><td class="c-table__cell u-text">callable</td><td class="c-table__cell u-text"> An optional optimizer. Should take two arguments <code>weights</code> and <code>gradient</code>, and an optional ID. Will be created via <a class="u-no-border u-inline-block u-nowrap" href="tagger#create_optimizer" target="_self"><code>create_optimizer</code> <svg aria-hidden="true" class="o-icon o-icon--inline u-color-theme" height="16" style="min-width: 16px" viewbox="0 0 16 16" width="16"><use xlink:href="#svg_book"></use></svg></a> if not set.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">callable</td><td class="c-table__cell u-text">An optimizer.</td></tr></table>
Tagger.create_optimizer	 Create an optmizer for the pipeline component.	<p> Create an optmizer for the pipeline component.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">tagger = Tagger(nlp.vocab)<br/>optimizer = tagger.create_optimizer()<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">callable</td><td class="c-table__cell u-text">The optimizer.</td></tr></table>
Tagger.use_params	Modify the pipe's model, to use the given parameter values.	<p>Modify the pipe's model, to use the given parameter values.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">tagger = Tagger(nlp.vocab)<br/>with tagger.use_params():<br/>    tagger.to_disk('/best_model')<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>params</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text"> The parameter values to use in the model. At the end of thecontext, the original parameters are restored.</td></tr></table>
Tagger.add_label	Add a new label to the pipe.	<p>Add a new label to the pipe.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">tagger = Tagger(nlp.vocab)<br/>tagger.add_label('MY_LABEL', {POS: 'NOUN'})</code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>label</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">The label to add.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>values</code></td><td class="c-table__cell u-text">dict</td><td class="c-table__cell u-text"> Optional values to map to the label, e.g. a tag mapdictionary.</td></tr></table>
Tagger.to_disk	Serialize the pipe to disk.	<p>Serialize the pipe to disk.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">tagger = Tagger(nlp.vocab)<br/>tagger.to_disk('/path/to/tagger')<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>path</code></td><td class="c-table__cell u-text">unicode or <code>Path</code></td><td class="c-table__cell u-text"> A path to a directory, which will be created if it doesn't exist. Paths may be either strings or <code>Path</code>-like objects.</td></tr></table>
Tagger.from_disk	Load the pipe from disk. Modifies the object in place and returns it.	<p>Load the pipe from disk. Modifies the object in place and returns it.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">tagger = Tagger(nlp.vocab)<br/>tagger.from_disk('/path/to/tagger')<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>path</code></td><td class="c-table__cell u-text">unicode or <code>Path</code></td><td class="c-table__cell u-text"> A path to a directory. Paths may be either strings or <code>Path</code>-like objects.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code>Tagger</code></td><td class="c-table__cell u-text">The modified <code>Tagger</code> object.</td></tr></table>
Tagger.to_bytes		<aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">tagger = Tagger(nlp.vocab)<br/>tagger_bytes = tagger.to_bytes()<br/></code></pre></div></aside><p>Serialize the pipe to a bytestring.</p><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>**exclude</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text">Named attributes to prevent from being serialized.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">bytes</td><td class="c-table__cell u-text">The serialized form of the <code>Tagger</code> object.</td></tr></table>
Tagger.from_bytes	Load the pipe from a bytestring. Modifies the object in place and returns it.	<p>Load the pipe from a bytestring. Modifies the object in place and returns it.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">tagger_bytes = tagger.to_bytes()<br/>tagger = Tagger(nlp.vocab)<br/>tagger.from_bytes(tagger_bytes)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>bytes_data</code></td><td class="c-table__cell u-text">bytes</td><td class="c-table__cell u-text">The data to load from.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>**exclude</code></td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text">Named attributes to prevent from being loaded.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code>Tagger</code></td><td class="c-table__cell u-text">The <code>Tagger</code> object.</td></tr></table>
Lexeme.__init__	Create a Lexeme object.	<p>Create a <code>Lexeme</code> object.</p><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>vocab</code></td><td class="c-table__cell u-text"><code>Vocab</code></td><td class="c-table__cell u-text">The parent vocabulary.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>orth</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">The orth id of the lexeme.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code>Lexeme</code></td><td class="c-table__cell u-text">The newly constructed object.</td></tr></table>
Lexeme.set_flag	Change the value of a boolean flag.	<p>Change the value of a boolean flag.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">COOL_FLAG = nlp.vocab.add_flag(lambda text: False)<br/>nlp.vocab[u'spaCy'].set_flag(COOL_FLAG, True)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>flag_id</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">The attribute ID of the flag to set.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>value</code></td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text">The new value of the flag.</td></tr></table>
Lexeme.check_flag	Check the value of a boolean flag.	<p>Check the value of a boolean flag.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">is_my_library = lambda text: text in ['spaCy', 'Thinc']<br/>MY_LIBRARY = nlp.vocab.add_flag(is_my_library)<br/>assert nlp.vocab[u'spaCy'].check_flag(MY_LIBRARY) == True<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>flag_id</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">The attribute ID of the flag to query.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text">The value of the flag.</td></tr></table>
Lexeme.similarity	Compute a semantic similarity estimate. Defaults to cosine over vectors.	<p>Compute a semantic similarity estimate. Defaults to cosine over vectors.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">apple = nlp.vocab[u'apple']<br/>orange = nlp.vocab[u'orange']<br/>apple_orange = apple.similarity(orange)<br/>orange_apple = orange.similarity(apple)<br/>assert apple_orange == orange_apple<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text">other</td><td class="c-table__cell u-text">-</td><td class="c-table__cell u-text"> The object to compare with. By default, accepts <code>Doc</code>, <code>Span</code>, <code>Token</code> and <code>Lexeme</code> objects.</td></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">float</td><td class="c-table__cell u-text">A scalar similarity score. Higher is more similar.</td></tr></table>
Lexeme.has_vector	 A boolean value indicating whether a word vector is associated with the
lexeme.	<p> A boolean value indicating whether a word vector is associated with thelexeme.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">apple = nlp.vocab[u'apple']<br/>assert apple.has_vector<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text">Whether the lexeme has a vector data attached.</td></tr></table>
Lexeme.vector	A real-valued meaning representation.	<p>A real-valued meaning representation.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">apple = nlp.vocab[u'apple']<br/>assert apple.vector.dtype == 'float32'<br/>assert apple.vector.shape == (300,)<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text"><code class="u-break">numpy.ndarray[ndim=1, dtype='float32']</code></td><td class="c-table__cell u-text">A 1D numpy array representing the lexeme's semantics.</td></tr></table>
Lexeme.vector_norm	The L2 norm of the lexeme's vector representation.	<p>The L2 norm of the lexeme's vector representation.</p><aside class="c-aside"><div class="c-aside__content" role="complementary"><h4 class="u-text-label u-text-label--dark"> Example</h4><pre class="c-code-block o-block lang-python o-no-block" data-language="python"><code class="c-code-block__content">apple = nlp.vocab[u'apple']<br/>pasta = nlp.vocab[u'pasta']<br/>apple.vector_norm # 7.1346845626831055<br/>pasta.vector_norm # 7.759851932525635<br/>assert apple.vector_norm != pasta.vector_norm<br/></code></pre></div></aside><table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row c-table__row--foot"><td class="c-table__cell u-text">returns</td><td class="c-table__cell u-text">float</td><td class="c-table__cell u-text">The L2 norm of the vector representation.</td></tr></table>
Attributes		<table class="c-table o-block"><tr class="c-table__row c-table__row--head"><th class="c-table__head-cell u-text-label">Name</th><th class="c-table__head-cell u-text-label">Type</th><th class="c-table__head-cell u-text-label">Description</th></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>vocab</code></td><td class="c-table__cell u-text"><code>Vocab</code></td><td class="c-table__cell u-text">The lexeme's vocabulary.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>text</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">Verbatim text content.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>orth</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">ID of the verbatim text content.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>orth_</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text"> Verbatim text content (identical to <code>Lexeme.text</code>). Existst mostly for consistency with the other attributes.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>lex_id</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">ID of the lexeme's lexical type.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>rank</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text"> Sequential ID of the lexemes's lexical type, used to index intotables, e.g. for word vectors.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>flags</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">Container of the lexeme's binary flags.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>norm</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">The lexemes's norm, i.e. a normalised form of the lexeme text.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>norm_</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">The lexemes's norm, i.e. a normalised form of the lexeme text.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>lower</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">Lowercase form of the word.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>lower_</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">Lowercase form of the word.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>shape</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">Transform of the word's string, to show orthographic features.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>shape_</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">Transform of the word's string, to show orthographic features.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>prefix</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text"> Length-N substring from the start of the word. Defaults to <code>N=1</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>prefix_</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text"> Length-N substring from the start of the word. Defaults to <code>N=1</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>suffix</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text"> Length-N substring from the end of the word. Defaults to <code>N=3</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>suffix_</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text"> Length-N substring from the start of the word. Defaults to <code>N=3</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>is_alpha</code></td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text"> Does the lexeme consist of alphabetic characters? Equivalent to <code>lexeme.text.isalpha()</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>is_ascii</code></td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text"> Does the lexeme consist of ASCII characters? Equivalent to <code>[any(ord(c) &gt;= 128 for c in lexeme.text)]</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>is_digit</code></td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text"> Does the lexeme consist of digits? Equivalent to <code>lexeme.text.isdigit()</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>is_lower</code></td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text"> Is the lexeme in lowercase? Equivalent to <code>lexeme.text.islower()</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>is_upper</code></td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text"> Is the lexeme in uppercase? Equivalent to <code>lexeme.text.isupper()</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>is_title</code></td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text"> Is the lexeme in titlecase? Equivalent to <code>lexeme.text.istitle()</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>is_punct</code></td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text">Is the lexeme punctuation?</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>is_left_punct</code></td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text">Is the lexeme a left punctuation mark, e.g. <code>(</code>?</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>is_right_punct</code></td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text">Is the lexeme a right punctuation mark, e.g. <code> </code>]?</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>is_space</code></td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text"> Does the lexeme consist of whitespace characters? Equivalent to <code>lexeme.text.isspace()</code>.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>is_bracket</code></td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text">Is the lexeme a bracket?</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>is_quote</code></td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text">Is the lexeme a quotation mark?</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>is_currency</code><div class="u-text-tag u-text-tag--spaced" data-tooltip="This feature is new and was introduced in spaCy v2.0.8">v2.0.8 <span aria-role="tooltip" class="u-hidden">This feature is new and was introduced in spaCy v2.0.8</span></div></td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text">Is the lexeme a currency symbol?</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>like_url</code></td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text">Does the lexeme resemble a URL?</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>like_num</code></td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text">Does the lexeme represent a number? e.g. "10.9", "10", "ten", etc.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>like_email</code></td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text">Does the lexeme resemble an email address?</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>is_oov</code></td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text">Is the lexeme out-of-vocabulary?</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>is_stop</code></td><td class="c-table__cell u-text">bool</td><td class="c-table__cell u-text">Is the lexeme part of a "stop list"?</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>lang</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">Language of the parent vocabulary.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>lang_</code></td><td class="c-table__cell u-text">unicode</td><td class="c-table__cell u-text">Language of the parent vocabulary.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>prob</code></td><td class="c-table__cell u-text">float</td><td class="c-table__cell u-text">Smoothed log probability estimate of the lexeme's type.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>cluster</code></td><td class="c-table__cell u-text">int</td><td class="c-table__cell u-text">Brown cluster ID.</td></tr><tr class="c-table__row"><td class="c-table__cell u-text"><code>sentiment</code></td><td class="c-table__cell u-text">float</td><td class="c-table__cell u-text"> A scalar value indicating the positivity or negativity of thelexeme.</td></tr></table>
